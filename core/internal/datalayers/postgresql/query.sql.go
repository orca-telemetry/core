// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package postgresql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAlgorithm = `-- name: CreateAlgorithm :exec
WITH processor_id AS (
  SELECT id FROM processor p
  WHERE p.name = $5 
  AND p.runtime = $6
),
window_type_id AS (
  SELECT id FROM window_type w
  WHERE w.name = $7 
  AND w.version = $8
)
INSERT INTO algorithm (
  name,
  version,
  description,
  processor_id,
  window_type_id,
  result_type
) VALUES (
  $1,
  $2,
  $3,
  (SELECT id FROM processor_id),
  (SELECT id FROM window_type_id),
  $4
) ON CONFLICT DO NOTHING
`

type CreateAlgorithmParams struct {
	Name              string
	Version           string
	Description       string
	ResultType        ResultType
	ProcessorName     string
	ProcessorRuntime  string
	WindowTypeName    string
	WindowTypeVersion string
}

func (q *Queries) CreateAlgorithm(ctx context.Context, arg CreateAlgorithmParams) error {
	_, err := q.db.Exec(ctx, createAlgorithm,
		arg.Name,
		arg.Version,
		arg.Description,
		arg.ResultType,
		arg.ProcessorName,
		arg.ProcessorRuntime,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
	)
	return err
}

const createAlgorithmDependency = `-- name: CreateAlgorithmDependency :exec
WITH from_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $1
  AND a.version = $2
  AND p.name = $3
  AND p.runtime = $4
),
to_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $5
  AND a.version = $6
  AND p.name = $7
  AND p.runtime = $8
)
INSERT INTO algorithm_dependency (
  from_algorithm_id,
  to_algorithm_id,
  from_window_type_id,
  to_window_type_id,
  from_processor_id,
  to_processor_id
) VALUES (
  (SELECT id FROM from_algo LIMIT 1),
  (SELECT id FROM to_algo LIMIT 1),
  (SELECT window_type_id FROM from_algo LIMIT 1),
  (SELECT window_type_id FROM to_algo LIMIT 1),
  (SELECT processor_id FROM from_algo LIMIT 1),
  (SELECT processor_id FROM to_algo LIMIT 1)
) ON CONFLICT (from_algorithm_id, to_algorithm_id) DO UPDATE
  SET
    from_window_type_id = excluded.from_window_type_id,
    to_window_type_id = excluded.to_window_type_id,
    from_processor_id = excluded.from_processor_id,
    to_processor_id = excluded.to_processor_id
`

type CreateAlgorithmDependencyParams struct {
	FromAlgorithmName    string
	FromAlgorithmVersion string
	FromProcessorName    string
	FromProcessorRuntime string
	ToAlgorithmName      string
	ToAlgorithmVersion   string
	ToProcessorName      string
	ToProcessorRuntime   string
}

func (q *Queries) CreateAlgorithmDependency(ctx context.Context, arg CreateAlgorithmDependencyParams) error {
	_, err := q.db.Exec(ctx, createAlgorithmDependency,
		arg.FromAlgorithmName,
		arg.FromAlgorithmVersion,
		arg.FromProcessorName,
		arg.FromProcessorRuntime,
		arg.ToAlgorithmName,
		arg.ToAlgorithmVersion,
		arg.ToProcessorName,
		arg.ToProcessorRuntime,
	)
	return err
}

const createMetadataField = `-- name: CreateMetadataField :one
INSERT INTO metadata_fields (
  name,
  description
) VALUES (
  $1,
  $2
) ON CONFLICT (name) DO UPDATE
SET
  name = EXCLUDED.name,
  description = EXCLUDED.description
RETURNING id
`

type CreateMetadataFieldParams struct {
	Name        string
	Description string
}

func (q *Queries) CreateMetadataField(ctx context.Context, arg CreateMetadataFieldParams) (int64, error) {
	row := q.db.QueryRow(ctx, createMetadataField, arg.Name, arg.Description)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createProcessor = `-- name: CreateProcessor :exec
INSERT INTO processor (
  name,
  runtime,
  connection_string
) VALUES (
  $1,
  $2,
  $3
) ON CONFLICT (name, runtime) DO UPDATE 
SET 
  name = EXCLUDED.name,
  runtime = EXCLUDED.runtime,
  connection_string = EXCLUDED.connection_string
RETURNING id
`

type CreateProcessorParams struct {
	Name             string
	Runtime          string
	ConnectionString string
}

// -------------------- Core Operations ----------------------
func (q *Queries) CreateProcessor(ctx context.Context, arg CreateProcessorParams) error {
	_, err := q.db.Exec(ctx, createProcessor, arg.Name, arg.Runtime, arg.ConnectionString)
	return err
}

const createResult = `-- name: CreateResult :one
INSERT INTO results (
  windows_id,
  window_type_id, 
  algorithm_id, 
  result_value,
  result_array,
  result_json
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
) RETURNING id
`

type CreateResultParams struct {
	WindowsID    pgtype.Int8
	WindowTypeID pgtype.Int8
	AlgorithmID  pgtype.Int8
	ResultValue  pgtype.Float8
	ResultArray  []float64
	ResultJson   []byte
}

func (q *Queries) CreateResult(ctx context.Context, arg CreateResultParams) (int64, error) {
	row := q.db.QueryRow(ctx, createResult,
		arg.WindowsID,
		arg.WindowTypeID,
		arg.AlgorithmID,
		arg.ResultValue,
		arg.ResultArray,
		arg.ResultJson,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWindowType = `-- name: CreateWindowType :one
INSERT INTO window_type (
  name,
  version,
  description
) VALUES (
  $1,
  $2,
  $3
) ON CONFLICT (name, version) DO UPDATE
SET
  name = EXCLUDED.name,
  version = EXCLUDED.version,
  description = EXCLUDED.description
RETURNING id
`

type CreateWindowTypeParams struct {
	Name        string
	Version     string
	Description string
}

func (q *Queries) CreateWindowType(ctx context.Context, arg CreateWindowTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createWindowType, arg.Name, arg.Version, arg.Description)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createWindowTypeMetadataFieldBridge = `-- name: CreateWindowTypeMetadataFieldBridge :exec
INSERT INTO metadata_fields_references (
  window_type_id,
  metadata_fields_id
) VALUES (
  $1,
  $2
) ON CONFLICT (window_type_id, metadata_fields_id) DO UPDATE
SET 
  window_type_id = EXCLUDED.window_type_id,
  metadata_fields_id = EXCLUDED.metadata_fields_id
`

type CreateWindowTypeMetadataFieldBridgeParams struct {
	WindowTypeID     int64
	MetadataFieldsID int64
}

func (q *Queries) CreateWindowTypeMetadataFieldBridge(ctx context.Context, arg CreateWindowTypeMetadataFieldBridgeParams) error {
	_, err := q.db.Exec(ctx, createWindowTypeMetadataFieldBridge, arg.WindowTypeID, arg.MetadataFieldsID)
	return err
}

const readAlgorithmExecutionPaths = `-- name: ReadAlgorithmExecutionPaths :many
SELECT aep.final_algo_id, aep.num_dependencies, aep.algo_id_path, aep.window_type_id_path, aep.proc_id_path FROM algorithm_execution_paths aep WHERE aep.window_type_id_path ~ ('*.' || $1::TEXT || '.*')::lquery
`

func (q *Queries) ReadAlgorithmExecutionPaths(ctx context.Context, windowTypeID string) ([]AlgorithmExecutionPath, error) {
	rows, err := q.db.Query(ctx, readAlgorithmExecutionPaths, windowTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmExecutionPath
	for rows.Next() {
		var i AlgorithmExecutionPath
		if err := rows.Scan(
			&i.FinalAlgoID,
			&i.NumDependencies,
			&i.AlgoIDPath,
			&i.WindowTypeIDPath,
			&i.ProcIDPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmExecutionPathsForAlgo = `-- name: ReadAlgorithmExecutionPathsForAlgo :many
SELECT aep.final_algo_id, aep.num_dependencies, aep.algo_id_path, aep.window_type_id_path, aep.proc_id_path FROM algorithm_execution_paths aep WHERE aep.final_algo_id=$1
`

func (q *Queries) ReadAlgorithmExecutionPathsForAlgo(ctx context.Context, algoID int64) ([]AlgorithmExecutionPath, error) {
	rows, err := q.db.Query(ctx, readAlgorithmExecutionPathsForAlgo, algoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmExecutionPath
	for rows.Next() {
		var i AlgorithmExecutionPath
		if err := rows.Scan(
			&i.FinalAlgoID,
			&i.NumDependencies,
			&i.AlgoIDPath,
			&i.WindowTypeIDPath,
			&i.ProcIDPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmId = `-- name: ReadAlgorithmId :one
WITH processor_id AS (
  SELECT p.id FROM processor p
  WHERE p.name = $3
  AND p.runtime = $4
)
SELECT a.id FROM algorithm a
WHERE a.name = $1
AND a.version = $2
AND a.processor_id = (SELECT id from processor_id)
`

type ReadAlgorithmIdParams struct {
	AlgorithmName    string
	AlgorithmVersion string
	ProcessorName    string
	ProcessorRuntime string
}

func (q *Queries) ReadAlgorithmId(ctx context.Context, arg ReadAlgorithmIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, readAlgorithmId,
		arg.AlgorithmName,
		arg.AlgorithmVersion,
		arg.ProcessorName,
		arg.ProcessorRuntime,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const readAlgorithms = `-- name: ReadAlgorithms :many
SELECT a.id, a.name, a.version, a.processor_id, a.window_type_id, a.result_type, a.created, a.description FROM algorithm a
`

func (q *Queries) ReadAlgorithms(ctx context.Context) ([]Algorithm, error) {
	rows, err := q.db.Query(ctx, readAlgorithms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Algorithm
	for rows.Next() {
		var i Algorithm
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.ProcessorID,
			&i.WindowTypeID,
			&i.ResultType,
			&i.Created,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmsForProcessorId = `-- name: ReadAlgorithmsForProcessorId :many
SELECT a.id, a.name, a.version, a.processor_id, a.window_type_id, a.result_type, a.created, a.description FROM algorithm a
WHERE a.processor_id = $1
`

func (q *Queries) ReadAlgorithmsForProcessorId(ctx context.Context, processorID int64) ([]Algorithm, error) {
	rows, err := q.db.Query(ctx, readAlgorithmsForProcessorId, processorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Algorithm
	for rows.Next() {
		var i Algorithm
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.ProcessorID,
			&i.WindowTypeID,
			&i.ResultType,
			&i.Created,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAlgorithmsForWindow = `-- name: ReadAlgorithmsForWindow :many
SELECT a.id, a.name, a.version, a.processor_id, a.window_type_id, a.result_type, a.created, a.description FROM algorithm a
JOIN window_type wt ON a.window_type_id = wt.id
WHERE wt.name = $1 
AND wt.version = $2
`

type ReadAlgorithmsForWindowParams struct {
	WindowTypeName    string
	WindowTypeVersion string
}

func (q *Queries) ReadAlgorithmsForWindow(ctx context.Context, arg ReadAlgorithmsForWindowParams) ([]Algorithm, error) {
	rows, err := q.db.Query(ctx, readAlgorithmsForWindow, arg.WindowTypeName, arg.WindowTypeVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Algorithm
	for rows.Next() {
		var i Algorithm
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.ProcessorID,
			&i.WindowTypeID,
			&i.ResultType,
			&i.Created,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readAllProcessors = `-- name: ReadAllProcessors :many
SELECT 
  id,
  name,
  runtime,
  connection_string,
  created
FROM processor
ORDER BY name, runtime
`

func (q *Queries) ReadAllProcessors(ctx context.Context) ([]Processor, error) {
	rows, err := q.db.Query(ctx, readAllProcessors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Processor
	for rows.Next() {
		var i Processor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Runtime,
			&i.ConnectionString,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readFromAlgorithmDependencies = `-- name: ReadFromAlgorithmDependencies :many
WITH from_algo AS (
  SELECT a.id, a.window_type_id, a.processor_id FROM algorithm a
  JOIN processor p ON a.processor_id = p.id
  WHERE a.name = $1
  AND a.version = $2
  AND p.name = $3
  AND p.runtime = $4
)
SELECT ad.id, ad.from_algorithm_id, ad.to_algorithm_id, ad.from_window_type_id, ad.to_window_type_id, ad.from_processor_id, ad.to_processor_id, ad.created FROM algorithm_dependency ad WHERE ad.from_algorithm_id = from_algo.id
`

type ReadFromAlgorithmDependenciesParams struct {
	FromAlgorithmName    string
	FromAlgorithmVersion string
	FromProcessorName    string
	FromProcessorRuntime string
}

func (q *Queries) ReadFromAlgorithmDependencies(ctx context.Context, arg ReadFromAlgorithmDependenciesParams) ([]AlgorithmDependency, error) {
	rows, err := q.db.Query(ctx, readFromAlgorithmDependencies,
		arg.FromAlgorithmName,
		arg.FromAlgorithmVersion,
		arg.FromProcessorName,
		arg.FromProcessorRuntime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlgorithmDependency
	for rows.Next() {
		var i AlgorithmDependency
		if err := rows.Scan(
			&i.ID,
			&i.FromAlgorithmID,
			&i.ToAlgorithmID,
			&i.FromWindowTypeID,
			&i.ToWindowTypeID,
			&i.FromProcessorID,
			&i.ToProcessorID,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readMetadataFieldsByWindowType = `-- name: ReadMetadataFieldsByWindowType :many
SELECT 
    metadata_field_id,
    metadata_field_name,
    metadata_field_description
FROM window_type_metadata_fields
WHERE window_type_name = $1
  AND window_type_version = $2
ORDER BY metadata_field_name
`

type ReadMetadataFieldsByWindowTypeParams struct {
	WindowTypeName    string
	WindowTypeVersion string
}

type ReadMetadataFieldsByWindowTypeRow struct {
	MetadataFieldID          int64
	MetadataFieldName        string
	MetadataFieldDescription string
}

func (q *Queries) ReadMetadataFieldsByWindowType(ctx context.Context, arg ReadMetadataFieldsByWindowTypeParams) ([]ReadMetadataFieldsByWindowTypeRow, error) {
	rows, err := q.db.Query(ctx, readMetadataFieldsByWindowType, arg.WindowTypeName, arg.WindowTypeVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReadMetadataFieldsByWindowTypeRow
	for rows.Next() {
		var i ReadMetadataFieldsByWindowTypeRow
		if err := rows.Scan(&i.MetadataFieldID, &i.MetadataFieldName, &i.MetadataFieldDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readProcessorsByIDs = `-- name: ReadProcessorsByIDs :many
SELECT 
  id,
  name,
  runtime,
  connection_string,
  created
FROM processor
WHERE id = ANY($1::bigint[])
ORDER BY name, runtime
`

func (q *Queries) ReadProcessorsByIDs(ctx context.Context, processorIds []int64) ([]Processor, error) {
	rows, err := q.db.Query(ctx, readProcessorsByIDs, processorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Processor
	for rows.Next() {
		var i Processor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Runtime,
			&i.ConnectionString,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const readWindowTypes = `-- name: ReadWindowTypes :many
SELECT wt.id, wt.name, wt.version, wt.description, wt.created FROM window_type wt
`

func (q *Queries) ReadWindowTypes(ctx context.Context) ([]WindowType, error) {
	rows, err := q.db.Query(ctx, readWindowTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WindowType
	for rows.Next() {
		var i WindowType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Description,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerWindow = `-- name: RegisterWindow :one
WITH window_type_id AS (
  SELECT id FROM window_type 
  WHERE name = $5 
  AND version = $6
)
INSERT INTO windows (
  window_type_id,
  time_from, 
  time_to,
  origin, 
  metadata
) VALUES (
  (SELECT id FROM window_type_id),
  $1,
  $2,
  $3,
  $4
) RETURNING window_type_id, id
`

type RegisterWindowParams struct {
	TimeFrom          pgtype.Timestamp
	TimeTo            pgtype.Timestamp
	Origin            string
	Metadata          []byte
	WindowTypeName    string
	WindowTypeVersion string
}

type RegisterWindowRow struct {
	WindowTypeID int64
	ID           int64
}

func (q *Queries) RegisterWindow(ctx context.Context, arg RegisterWindowParams) (RegisterWindowRow, error) {
	row := q.db.QueryRow(ctx, registerWindow,
		arg.TimeFrom,
		arg.TimeTo,
		arg.Origin,
		arg.Metadata,
		arg.WindowTypeName,
		arg.WindowTypeVersion,
	)
	var i RegisterWindowRow
	err := row.Scan(&i.WindowTypeID, &i.ID)
	return i, err
}
