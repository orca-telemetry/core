// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { ListValue, Struct, Value } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "";

export enum ResultType {
  /** NOT_SPECIFIED - placeholder sentinel to make explicit that nothing was provided */
  NOT_SPECIFIED = 0,
  /** STRUCT - the algorithm produces a struct result */
  STRUCT = 1,
  /** VALUE - the algorithm produces a single value */
  VALUE = 2,
  /** ARRAY - the algorithm produces an array of values */
  ARRAY = 3,
  /** NONE - the algorithm does not produce a result */
  NONE = 4,
  UNRECOGNIZED = -1,
}

export function resultTypeFromJSON(object: any): ResultType {
  switch (object) {
    case 0:
    case "NOT_SPECIFIED":
      return ResultType.NOT_SPECIFIED;
    case 1:
    case "STRUCT":
      return ResultType.STRUCT;
    case 2:
    case "VALUE":
      return ResultType.VALUE;
    case 3:
    case "ARRAY":
      return ResultType.ARRAY;
    case 4:
    case "NONE":
      return ResultType.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultType.UNRECOGNIZED;
  }
}

export function resultTypeToJSON(object: ResultType): string {
  switch (object) {
    case ResultType.NOT_SPECIFIED:
      return "NOT_SPECIFIED";
    case ResultType.STRUCT:
      return "STRUCT";
    case ResultType.VALUE:
      return "VALUE";
    case ResultType.ARRAY:
      return "ARRAY";
    case ResultType.NONE:
      return "NONE";
    case ResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ResultStatus indicates the outcome of algorithm execution */
export enum ResultStatus {
  /**
   * RESULT_STATUS_HANDLED_FAILED - Algorithm failed but the error was handled gracefully
   * The system may retry or skip depending on configuration
   */
  RESULT_STATUS_HANDLED_FAILED = 0,
  /**
   * RESULT_STATUS_UNHANDLED_FAILED - Algorithm failed with an unexpected error
   * Requires investigation and may halt dependent processing
   */
  RESULT_STATUS_UNHANDLED_FAILED = 1,
  /**
   * RESULT_STATUS_SUCEEDED - Algorithm completed successfully
   * Results are valid and can be used by dependent algorithms
   */
  RESULT_STATUS_SUCEEDED = 2,
  UNRECOGNIZED = -1,
}

export function resultStatusFromJSON(object: any): ResultStatus {
  switch (object) {
    case 0:
    case "RESULT_STATUS_HANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_HANDLED_FAILED;
    case 1:
    case "RESULT_STATUS_UNHANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_UNHANDLED_FAILED;
    case 2:
    case "RESULT_STATUS_SUCEEDED":
      return ResultStatus.RESULT_STATUS_SUCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultStatus.UNRECOGNIZED;
  }
}

export function resultStatusToJSON(object: ResultStatus): string {
  switch (object) {
    case ResultStatus.RESULT_STATUS_HANDLED_FAILED:
      return "RESULT_STATUS_HANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_UNHANDLED_FAILED:
      return "RESULT_STATUS_UNHANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_SUCEEDED:
      return "RESULT_STATUS_SUCEEDED";
    case ResultStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Window represents a time-bounded processing context that triggers algorithm execution. Windows are the primary input that start DAG processing flows. */
export interface Window {
  /**
   * Time that the window starts - nanoseconds since epoch
   * Required: Must be > Unix epoch (1970-01-01T00:00:00Z)
   */
  timeFrom?:
    | Date
    | undefined;
  /**
   * Time that the window ends - nanoseconds since epoch
   * Required: Must be > time_from (validated at message level)
   */
  timeTo?:
    | Date
    | undefined;
  /** The canonical name of the window that uniquely identifies it */
  windowTypeName?:
    | string
    | undefined;
  /** The version of the window type */
  windowTypeVersion?:
    | string
    | undefined;
  /** A unique identifier that defines where the window came from */
  origin?:
    | string
    | undefined;
  /**
   * Additional metadata to attach to this window
   * The schema of this metadata is determined by the combination of
   * window_type_name and window_type_version. Each window type version
   * defines its own required and optional metadata fields, as defined
   * at the time of registration.
   */
  metadata?: { [key: string]: any } | undefined;
}

/** MetadataField describes the metadata that can be carried along with windows */
export interface MetadataField {
  /**
   * Name of the metadata field
   * Examples: "AssetID"
   */
  name?:
    | string
    | undefined;
  /**
   * Description of the field
   * Examples: "Unique ID of the asset"
   */
  description?: string | undefined;
}

/**
 * WindowType defines a category of window that can trigger algorithms.
 * Algorithms subscribe to window types to indicate when they should be executed.
 */
export interface WindowType {
  /**
   * Name of the window type - must be globally unique
   * Examples: "daily", "hourly", "market_close", "event_triggered"
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm. Follows basic semver and allows window
   * types to be changed over time, with traceability
   */
  version?:
    | string
    | undefined;
  /**
   * Description of the window
   * E.g. "Emitted every day, at noon"
   */
  description?:
    | string
    | undefined;
  /** Metadata fields that are carried along with this window type */
  metadataFields?: MetadataField[] | undefined;
}

/** WindowEmitStatus status message returned after emitting a window */
export interface WindowEmitStatus {
  status?: WindowEmitStatus_StatusEnum | undefined;
}

/** A status enum that captures scenarios regarding a window being emmited */
export enum WindowEmitStatus_StatusEnum {
  /** TRIGGERING_FAILED - When triggering has failed */
  TRIGGERING_FAILED = 0,
  /** NO_TRIGGERED_ALGORITHMS - When no algorithms could be found that are triggered by this window */
  NO_TRIGGERED_ALGORITHMS = 1,
  /** PROCESSING_TRIGGERED - When processing has successfully been triggered */
  PROCESSING_TRIGGERED = 2,
  UNRECOGNIZED = -1,
}

export function windowEmitStatus_StatusEnumFromJSON(object: any): WindowEmitStatus_StatusEnum {
  switch (object) {
    case 0:
    case "TRIGGERING_FAILED":
      return WindowEmitStatus_StatusEnum.TRIGGERING_FAILED;
    case 1:
    case "NO_TRIGGERED_ALGORITHMS":
      return WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS;
    case 2:
    case "PROCESSING_TRIGGERED":
      return WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowEmitStatus_StatusEnum.UNRECOGNIZED;
  }
}

export function windowEmitStatus_StatusEnumToJSON(object: WindowEmitStatus_StatusEnum): string {
  switch (object) {
    case WindowEmitStatus_StatusEnum.TRIGGERING_FAILED:
      return "TRIGGERING_FAILED";
    case WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS:
      return "NO_TRIGGERED_ALGORITHMS";
    case WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED:
      return "PROCESSING_TRIGGERED";
    case WindowEmitStatus_StatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AlgorithmDependency defines a requirement that one algorithm has on another's results.
 * These dependencies form the edges in the processing DAG.
 */
export interface AlgorithmDependency {
  /**
   * Name of the required algorithm
   * Must reference an existing algorithm name in the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the required algorithm
   * Must follow semantic versioning (e.g., "1.0.0")
   */
  version?:
    | string
    | undefined;
  /** Name of the processor that the algorithm is associated with */
  processorName?:
    | string
    | undefined;
  /** Runtime of the processor that the algorithm is associated with */
  processorRuntime?: string | undefined;
}

export interface StructResultField {
  /**
   * Name of the struct result field
   * Examples: "P50"
   */
  name?:
    | string
    | undefined;
  /**
   * Description of the field
   * Examples: "50th percentile of signal"
   */
  description?: string | undefined;
}

/**
 * Algorithm defines a processing unit that can be executed by processors.
 * Algorithms form the nodes in the processing DAG and are triggered by specific window types.
 */
export interface Algorithm {
  /**
   * Name of the algorithm - must be globally unique
   * This identifies the algorithm across the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm - must follow semantic versioning
   * Allows for algorithm evolution while maintaining compatibility
   */
  version?:
    | string
    | undefined;
  /**
   * Type of window that triggers this algorithm
   * References a WindowType that will cause this algorithm to execute
   */
  windowType?:
    | WindowType
    | undefined;
  /**
   * Other algorithms that this algorithm depends on
   * The algorithm won't execute until all dependencies have completed
   * Dependencies must not form cycles - this is statically checked on processor registration
   */
  dependencies?:
    | AlgorithmDependency[]
    | undefined;
  /**
   * The type of result that the algorithm produces. This is specified upfront
   * rather than introspected, to allow for validation
   */
  resultType?:
    | ResultType
    | undefined;
  /** The result struct fields that are present. */
  structResultField?: StructResultField[] | undefined;
}

/** Container for array of float values */
export interface FloatArray {
  values?: number[] | undefined;
}

/** Result of an algorithm execution */
export interface Result {
  /** Status of the result execution */
  status?:
    | ResultStatus
    | undefined;
  /** The actual result data - can be either an array of floats or a structured object */
  resultData?:
    | //
    /** for single number results */
    { $case: "singleValue"; value: number }
    | //
    /** For numeric array results */
    { $case: "floatValues"; value: FloatArray }
    | //
    /**
     * For structured data results (JSON-like)
     * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
     */
    { $case: "structValue"; value: { [key: string]: any } | undefined }
    | undefined;
  /** Timestamp when the result was produced */
  timestamp?: string | undefined;
}

/**
 * ProcessorRegistration is sent by processors when they start up to announce their capabilities
 * to the orchestrator. This establishes a long-lived connection for receiving tasks.
 */
export interface ProcessorRegistration {
  /** Unique name of the runtime */
  name?:
    | string
    | undefined;
  /**
   * Language/runtime of the processor
   * Examples: "python3.9", "go1.19", "Rust4.1"
   */
  runtime?:
    | string
    | undefined;
  /**
   * The connection string of the processor
   * e.g. grpc://localhost:5433
   */
  connectionStr?:
    | string
    | undefined;
  /**
   * Algorithms this processor can execute
   * The processor must implement all listed algorithms
   */
  supportedAlgorithms?: Algorithm[] | undefined;
}

/**
 * ProcessingTask represents a single algorithm execution request sent to a processor.
 * Tasks are streamed to processors as their dependencies are satisfied.
 */
export interface ProcessingTask {
  /**
   * Unique ID for this specific task execution
   * Used to correlate results and track execution state
   */
  taskId?:
    | string
    | undefined;
  /**
   * Algorithm to execute
   * Must be one of the algorithms the processor registered support for
   */
  algorithm?:
    | Algorithm
    | undefined;
  /**
   * Window that triggered this task
   * Provides the time context for the algorithm execution
   */
  window?:
    | Window
    | undefined;
  /**
   * Results from dependent algorithms
   * Contains all results that this algorithm declared dependencies on
   * All dependencies will be present when task is sent
   */
  dependencyResults?: Result[] | undefined;
}

/**
 * ExecutionRequest provides a complete view of a processing DAG's execution
 * status for a specific window. Used for monitoring and debugging.
 */
export interface ExecutionRequest {
  /** The exec_id */
  execId?:
    | string
    | undefined;
  /** The window that triggered the algorithm */
  window?:
    | Window
    | undefined;
  /** Results from dependant algorithms */
  algorithmResults?:
    | AlgorithmResult[]
    | undefined;
  /** The algorithms to execute */
  algorithms?: Algorithm[] | undefined;
}

export interface ExecutionResult {
  /** Exec ID */
  execId?:
    | string
    | undefined;
  /** The algorithn result */
  algorithmResult?: AlgorithmResult | undefined;
}

/** AlgorithmWindowResult Packaged algorithm and result to a window */
export interface AlgorithmResult {
  algorithm?: Algorithm | undefined;
  result?: Result | undefined;
}

export interface Status {
  received?: boolean | undefined;
  message?: string | undefined;
}

/** HealthCheckRequest is sent to processors to verify they are functioning */
export interface HealthCheckRequest {
  /**
   * Timestamp of the request in unix epoch milliseconds
   * Used to measure response latency
   */
  timestamp?: string | undefined;
}

/** HealthCheckResponse indicates the health status of a processor */
export interface HealthCheckResponse {
  /** Current health status */
  status?:
    | HealthCheckResponse_Status
    | undefined;
  /** Optional message providing more detail about the health status */
  message?:
    | string
    | undefined;
  /** System metrics about the processor */
  metrics?: ProcessorMetrics | undefined;
}

/** Overall health status of the processor */
export enum HealthCheckResponse_Status {
  /** STATUS_UNKNOWN - Unknown status - should never be used */
  STATUS_UNKNOWN = 0,
  /** STATUS_SERVING - Processor is healthy and ready to accept tasks */
  STATUS_SERVING = 1,
  /** STATUS_TRANSITIONING - Processor is starting up or shutting down */
  STATUS_TRANSITIONING = 2,
  /** STATUS_NOT_SERVING - Processor is not healthy and cannot accept tasks */
  STATUS_NOT_SERVING = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_StatusFromJSON(object: any): HealthCheckResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return HealthCheckResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_SERVING":
      return HealthCheckResponse_Status.STATUS_SERVING;
    case 2:
    case "STATUS_TRANSITIONING":
      return HealthCheckResponse_Status.STATUS_TRANSITIONING;
    case 3:
    case "STATUS_NOT_SERVING":
      return HealthCheckResponse_Status.STATUS_NOT_SERVING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_Status.UNRECOGNIZED;
  }
}

export function healthCheckResponse_StatusToJSON(object: HealthCheckResponse_Status): string {
  switch (object) {
    case HealthCheckResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case HealthCheckResponse_Status.STATUS_SERVING:
      return "STATUS_SERVING";
    case HealthCheckResponse_Status.STATUS_TRANSITIONING:
      return "STATUS_TRANSITIONING";
    case HealthCheckResponse_Status.STATUS_NOT_SERVING:
      return "STATUS_NOT_SERVING";
    case HealthCheckResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ProcessorMetrics provides runtime information about a processor */
export interface ProcessorMetrics {
  /** Number of algorithms currently being executed */
  activeTasks?:
    | number
    | undefined;
  /** Memory usage in bytes */
  memoryBytes?:
    | string
    | undefined;
  /** CPU usage percentage (0-100) */
  cpuPercent?:
    | number
    | undefined;
  /** Time since processor started in seconds */
  uptimeSeconds?: string | undefined;
}

/** ---------------------------- Data Messages ---------------------------- */
export interface WindowTypeRead {
}

export interface WindowTypes {
  windows?: WindowType[] | undefined;
}

export interface AlgorithmsRead {
}

export interface Algorithms {
  algorithm?: Algorithm[] | undefined;
}

export interface ProcessorsRead {
}

export interface Processors {
  processor?: Processors_Processor[] | undefined;
}

export interface Processors_Processor {
  name?: string | undefined;
  runtime?: string | undefined;
}

export interface ResultsStatsRead {
}

export interface ResultsStats {
  Count?: string | undefined;
}

export interface AlgorithmFieldsRead {
  timeFrom?: Date | undefined;
  timeTo?: Date | undefined;
  algorithm?: Algorithm | undefined;
}

export interface AlgorithmFields {
  field?: string[] | undefined;
}

export interface ResultsForAlgorithmRead {
  /** the time to read results from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to read results to */
  timeTo?:
    | Date
    | undefined;
  /** the algorithm to read results for */
  algorithm?: Algorithm | undefined;
}

export interface ResultsForAlgorithm {
  results?: ResultsForAlgorithm_ResultsRow[] | undefined;
}

export interface ResultsForAlgorithm_ResultsRow {
  /** the time of the result, being the center of the triggering window */
  time?:
    | Date
    | undefined;
  /** the result packet is one of these */
  resultData?:
    | //
    /** for single number results */
    { $case: "singleValue"; value: number }
    | //
    /** For numeric array results */
    { $case: "arrayValues"; value: FloatArray }
    | //
    /**
     * For structured data results (JSON-like)
     * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
     */
    { $case: "structValue"; value: { [key: string]: any } | undefined }
    | undefined;
}

export interface WindowsRead {
  /** the time to read windows from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to read windows to */
  timeTo?:
    | Date
    | undefined;
  /** the window */
  window?: WindowType | undefined;
}

export interface Windows {
  /** the windows */
  window?: Window[] | undefined;
}

export interface DistinctMetadataForWindowTypeRead {
  /** the time to read windows from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to read windows to */
  timeTo?:
    | Date
    | undefined;
  /** the window type to read */
  windowType?: WindowType | undefined;
}

export interface DistinctMetadataForWindowType {
  metadata?: Array<any> | undefined;
}

export interface WindowsForMetadataRead {
  /** the time to read windows from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to read windows to */
  timeTo?:
    | Date
    | undefined;
  /** the window */
  window?: WindowType | undefined;
  metadata?: WindowsForMetadataRead_Metadata[] | undefined;
}

/** the metadata */
export interface WindowsForMetadataRead_Metadata {
  field?: string | undefined;
  value?: any | undefined;
}

export interface WindowsForMetadata {
  /** the windows */
  window?: Window[] | undefined;
}

export interface ResultsForAlgorithmAndMetadataRead {
  /** the time to read results from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to read results to */
  timeTo?:
    | Date
    | undefined;
  /** the algorithm to read results for */
  algorithm?: Algorithm | undefined;
  metadata?: ResultsForAlgorithmAndMetadataRead_Metadata[] | undefined;
}

export interface ResultsForAlgorithmAndMetadataRead_Metadata {
  field?: string | undefined;
  value?: any | undefined;
}

export interface ResultsForAlgorithmAndMetadata {
  results?: ResultsForAlgorithmAndMetadata_ResultsRow[] | undefined;
}

export interface ResultsForAlgorithmAndMetadata_ResultsRow {
  /** the time of the result, being the center of the triggering window */
  time?:
    | Date
    | undefined;
  /** the result packet is one of these */
  resultData?:
    | //
    /** for single number results */
    { $case: "singleValue"; value: number }
    | //
    /** For numeric array results */
    { $case: "arrayValues"; value: FloatArray }
    | //
    /**
     * For structured data results (JSON-like)
     * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
     */
    { $case: "structValue"; value: { [key: string]: any } | undefined }
    | undefined;
}

/** ------------------------ Annotation Messages ------------------------ */
export interface AnnotateWrite {
  /** the time to annotate from */
  timeFrom?:
    | Date
    | undefined;
  /** the time to annotate to */
  timeTo?:
    | Date
    | undefined;
  /** the algorithms within the annotation */
  capturedAlgorithms?:
    | Algorithm[]
    | undefined;
  /** the windows within the annotation */
  capturedWindows?:
    | WindowType[]
    | undefined;
  /** the description of the annotation */
  description?:
    | string
    | undefined;
  /** metadata to be attached to the annotation */
  metadata?: { [key: string]: any } | undefined;
}

export interface AnnotateResponse {
}

function createBaseWindow(): Window {
  return {
    timeFrom: undefined,
    timeTo: undefined,
    windowTypeName: "",
    windowTypeVersion: "",
    origin: "",
    metadata: undefined,
  };
}

export const Window: MessageFns<Window> = {
  encode(message: Window, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      writer.uint32(26).string(message.windowTypeName);
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      writer.uint32(34).string(message.windowTypeVersion);
    }
    if (message.origin !== undefined && message.origin !== "") {
      writer.uint32(42).string(message.origin);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Window {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowTypeVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Window {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      windowTypeName: isSet(object.windowTypeName) ? globalThis.String(object.windowTypeName) : "",
      windowTypeVersion: isSet(object.windowTypeVersion) ? globalThis.String(object.windowTypeVersion) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Window): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      obj.windowTypeName = message.windowTypeName;
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      obj.windowTypeVersion = message.windowTypeVersion;
    }
    if (message.origin !== undefined && message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Window>, I>>(base?: I): Window {
    return Window.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Window>, I>>(object: I): Window {
    const message = createBaseWindow();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.windowTypeName = object.windowTypeName ?? "";
    message.windowTypeVersion = object.windowTypeVersion ?? "";
    message.origin = object.origin ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseMetadataField(): MetadataField {
  return { name: "", description: "" };
}

export const MetadataField: MessageFns<MetadataField> = {
  encode(message: MetadataField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: MetadataField): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataField>, I>>(base?: I): MetadataField {
    return MetadataField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataField>, I>>(object: I): MetadataField {
    const message = createBaseMetadataField();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWindowType(): WindowType {
  return { name: "", version: "", description: "", metadataFields: [] };
}

export const WindowType: MessageFns<WindowType> = {
  encode(message: WindowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.metadataFields !== undefined && message.metadataFields.length !== 0) {
      for (const v of message.metadataFields) {
        MetadataField.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = MetadataField.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadataFields!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      metadataFields: globalThis.Array.isArray(object?.metadataFields)
        ? object.metadataFields.map((e: any) => MetadataField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WindowType): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadataFields?.length) {
      obj.metadataFields = message.metadataFields.map((e) => MetadataField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowType>, I>>(base?: I): WindowType {
    return WindowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowType>, I>>(object: I): WindowType {
    const message = createBaseWindowType();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    message.metadataFields = object.metadataFields?.map((e) => MetadataField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWindowEmitStatus(): WindowEmitStatus {
  return { status: 0 };
}

export const WindowEmitStatus: MessageFns<WindowEmitStatus> = {
  encode(message: WindowEmitStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowEmitStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowEmitStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowEmitStatus {
    return { status: isSet(object.status) ? windowEmitStatus_StatusEnumFromJSON(object.status) : 0 };
  },

  toJSON(message: WindowEmitStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = windowEmitStatus_StatusEnumToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(base?: I): WindowEmitStatus {
    return WindowEmitStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(object: I): WindowEmitStatus {
    const message = createBaseWindowEmitStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseAlgorithmDependency(): AlgorithmDependency {
  return { name: "", version: "", processorName: "", processorRuntime: "" };
}

export const AlgorithmDependency: MessageFns<AlgorithmDependency> = {
  encode(message: AlgorithmDependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      writer.uint32(26).string(message.processorName);
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      writer.uint32(34).string(message.processorRuntime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmDependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processorRuntime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmDependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      processorName: isSet(object.processorName) ? globalThis.String(object.processorName) : "",
      processorRuntime: isSet(object.processorRuntime) ? globalThis.String(object.processorRuntime) : "",
    };
  },

  toJSON(message: AlgorithmDependency): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      obj.processorName = message.processorName;
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      obj.processorRuntime = message.processorRuntime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(base?: I): AlgorithmDependency {
    return AlgorithmDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(object: I): AlgorithmDependency {
    const message = createBaseAlgorithmDependency();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.processorName = object.processorName ?? "";
    message.processorRuntime = object.processorRuntime ?? "";
    return message;
  },
};

function createBaseStructResultField(): StructResultField {
  return { name: "", description: "" };
}

export const StructResultField: MessageFns<StructResultField> = {
  encode(message: StructResultField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructResultField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructResultField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructResultField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: StructResultField): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StructResultField>, I>>(base?: I): StructResultField {
    return StructResultField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StructResultField>, I>>(object: I): StructResultField {
    const message = createBaseStructResultField();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseAlgorithm(): Algorithm {
  return { name: "", version: "", windowType: undefined, dependencies: [], resultType: 0, structResultField: [] };
}

export const Algorithm: MessageFns<Algorithm> = {
  encode(message: Algorithm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.windowType !== undefined) {
      WindowType.encode(message.windowType, writer.uint32(26).fork()).join();
    }
    if (message.dependencies !== undefined && message.dependencies.length !== 0) {
      for (const v of message.dependencies) {
        AlgorithmDependency.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.resultType !== undefined && message.resultType !== 0) {
      writer.uint32(40).int32(message.resultType);
    }
    if (message.structResultField !== undefined && message.structResultField.length !== 0) {
      for (const v of message.structResultField) {
        StructResultField.encode(v!, writer.uint32(50).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowType = WindowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = AlgorithmDependency.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencies!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.resultType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const el = StructResultField.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.structResultField!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithm {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      windowType: isSet(object.windowType) ? WindowType.fromJSON(object.windowType) : undefined,
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => AlgorithmDependency.fromJSON(e))
        : [],
      resultType: isSet(object.resultType) ? resultTypeFromJSON(object.resultType) : 0,
      structResultField: globalThis.Array.isArray(object?.structResultField)
        ? object.structResultField.map((e: any) => StructResultField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Algorithm): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.windowType !== undefined) {
      obj.windowType = WindowType.toJSON(message.windowType);
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => AlgorithmDependency.toJSON(e));
    }
    if (message.resultType !== undefined && message.resultType !== 0) {
      obj.resultType = resultTypeToJSON(message.resultType);
    }
    if (message.structResultField?.length) {
      obj.structResultField = message.structResultField.map((e) => StructResultField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithm>, I>>(base?: I): Algorithm {
    return Algorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithm>, I>>(object: I): Algorithm {
    const message = createBaseAlgorithm();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.windowType = (object.windowType !== undefined && object.windowType !== null)
      ? WindowType.fromPartial(object.windowType)
      : undefined;
    message.dependencies = object.dependencies?.map((e) => AlgorithmDependency.fromPartial(e)) || [];
    message.resultType = object.resultType ?? 0;
    message.structResultField = object.structResultField?.map((e) => StructResultField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFloatArray(): FloatArray {
  return { values: [] };
}

export const FloatArray: MessageFns<FloatArray> = {
  encode(message: FloatArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values !== undefined && message.values.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.values) {
        writer.float(v);
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values!.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values!.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatArray>, I>>(base?: I): FloatArray {
    return FloatArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatArray>, I>>(object: I): FloatArray {
    const message = createBaseFloatArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseResult(): Result {
  return { status: 0, resultData: undefined, timestamp: "0" };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    switch (message.resultData?.$case) {
      case "singleValue":
        writer.uint32(21).float(message.resultData.value);
        break;
      case "floatValues":
        FloatArray.encode(message.resultData.value, writer.uint32(26).fork()).join();
        break;
      case "structValue":
        Struct.encode(Struct.wrap(message.resultData.value), writer.uint32(34).fork()).join();
        break;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.resultData = { $case: "singleValue", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultData = { $case: "floatValues", value: FloatArray.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resultData = { $case: "structValue", value: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      status: isSet(object.status) ? resultStatusFromJSON(object.status) : 0,
      resultData: isSet(object.singleValue)
        ? { $case: "singleValue", value: globalThis.Number(object.singleValue) }
        : isSet(object.floatValues)
        ? { $case: "floatValues", value: FloatArray.fromJSON(object.floatValues) }
        : isSet(object.structValue)
        ? { $case: "structValue", value: object.structValue }
        : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = resultStatusToJSON(message.status);
    }
    if (message.resultData?.$case === "singleValue") {
      obj.singleValue = message.resultData.value;
    } else if (message.resultData?.$case === "floatValues") {
      obj.floatValues = FloatArray.toJSON(message.resultData.value);
    } else if (message.resultData?.$case === "structValue") {
      obj.structValue = message.resultData.value;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.status = object.status ?? 0;
    switch (object.resultData?.$case) {
      case "singleValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "singleValue", value: object.resultData.value };
        }
        break;
      }
      case "floatValues": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "floatValues", value: FloatArray.fromPartial(object.resultData.value) };
        }
        break;
      }
      case "structValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "structValue", value: object.resultData.value };
        }
        break;
      }
    }
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseProcessorRegistration(): ProcessorRegistration {
  return { name: "", runtime: "", connectionStr: "", supportedAlgorithms: [] };
}

export const ProcessorRegistration: MessageFns<ProcessorRegistration> = {
  encode(message: ProcessorRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      writer.uint32(26).string(message.connectionStr);
    }
    if (message.supportedAlgorithms !== undefined && message.supportedAlgorithms.length !== 0) {
      for (const v of message.supportedAlgorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectionStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.supportedAlgorithms!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorRegistration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      connectionStr: isSet(object.connectionStr) ? globalThis.String(object.connectionStr) : "",
      supportedAlgorithms: globalThis.Array.isArray(object?.supportedAlgorithms)
        ? object.supportedAlgorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessorRegistration): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      obj.connectionStr = message.connectionStr;
    }
    if (message.supportedAlgorithms?.length) {
      obj.supportedAlgorithms = message.supportedAlgorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(base?: I): ProcessorRegistration {
    return ProcessorRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(object: I): ProcessorRegistration {
    const message = createBaseProcessorRegistration();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    message.connectionStr = object.connectionStr ?? "";
    message.supportedAlgorithms = object.supportedAlgorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessingTask(): ProcessingTask {
  return { taskId: "", algorithm: undefined, window: undefined, dependencyResults: [] };
}

export const ProcessingTask: MessageFns<ProcessingTask> = {
  encode(message: ProcessingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== undefined && message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(26).fork()).join();
    }
    if (message.dependencyResults !== undefined && message.dependencyResults.length !== 0) {
      for (const v of message.dependencyResults) {
        Result.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Result.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencyResults!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      dependencyResults: globalThis.Array.isArray(object?.dependencyResults)
        ? object.dependencyResults.map((e: any) => Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessingTask): unknown {
    const obj: any = {};
    if (message.taskId !== undefined && message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.dependencyResults?.length) {
      obj.dependencyResults = message.dependencyResults.map((e) => Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingTask>, I>>(base?: I): ProcessingTask {
    return ProcessingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingTask>, I>>(object: I): ProcessingTask {
    const message = createBaseProcessingTask();
    message.taskId = object.taskId ?? "";
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.dependencyResults = object.dependencyResults?.map((e) => Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionRequest(): ExecutionRequest {
  return { execId: "", window: undefined, algorithmResults: [], algorithms: [] };
}

export const ExecutionRequest: MessageFns<ExecutionRequest> = {
  encode(message: ExecutionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(18).fork()).join();
    }
    if (message.algorithmResults !== undefined && message.algorithmResults.length !== 0) {
      for (const v of message.algorithmResults) {
        AlgorithmResult.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.algorithms !== undefined && message.algorithms.length !== 0) {
      for (const v of message.algorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = AlgorithmResult.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithmResults!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithms!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionRequest {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      algorithmResults: globalThis.Array.isArray(object?.algorithmResults)
        ? object.algorithmResults.map((e: any) => AlgorithmResult.fromJSON(e))
        : [],
      algorithms: globalThis.Array.isArray(object?.algorithms)
        ? object.algorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecutionRequest): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.algorithmResults?.length) {
      obj.algorithmResults = message.algorithmResults.map((e) => AlgorithmResult.toJSON(e));
    }
    if (message.algorithms?.length) {
      obj.algorithms = message.algorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionRequest>, I>>(base?: I): ExecutionRequest {
    return ExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionRequest>, I>>(object: I): ExecutionRequest {
    const message = createBaseExecutionRequest();
    message.execId = object.execId ?? "";
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.algorithmResults = object.algorithmResults?.map((e) => AlgorithmResult.fromPartial(e)) || [];
    message.algorithms = object.algorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { execId: "", algorithmResult: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.algorithmResult !== undefined) {
      AlgorithmResult.encode(message.algorithmResult, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithmResult = AlgorithmResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      algorithmResult: isSet(object.algorithmResult) ? AlgorithmResult.fromJSON(object.algorithmResult) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.algorithmResult !== undefined) {
      obj.algorithmResult = AlgorithmResult.toJSON(message.algorithmResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.execId = object.execId ?? "";
    message.algorithmResult = (object.algorithmResult !== undefined && object.algorithmResult !== null)
      ? AlgorithmResult.fromPartial(object.algorithmResult)
      : undefined;
    return message;
  },
};

function createBaseAlgorithmResult(): AlgorithmResult {
  return { algorithm: undefined, result: undefined };
}

export const AlgorithmResult: MessageFns<AlgorithmResult> = {
  encode(message: AlgorithmResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmResult {
    return {
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: AlgorithmResult): unknown {
    const obj: any = {};
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmResult>, I>>(base?: I): AlgorithmResult {
    return AlgorithmResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmResult>, I>>(object: I): AlgorithmResult {
    const message = createBaseAlgorithmResult();
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseStatus(): Status {
  return { received: false, message: "" };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.received !== undefined && message.received !== false) {
      writer.uint32(8).bool(message.received);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.received = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      received: isSet(object.received) ? globalThis.Boolean(object.received) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.received !== undefined && message.received !== false) {
      obj.received = message.received;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.received = object.received ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { timestamp: "0" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, message: "", metrics: undefined };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metrics !== undefined) {
      ProcessorMetrics.encode(message.metrics, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics = ProcessorMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthCheckResponse_StatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: isSet(object.metrics) ? ProcessorMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = healthCheckResponse_StatusToJSON(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics !== undefined) {
      obj.metrics = ProcessorMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ProcessorMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseProcessorMetrics(): ProcessorMetrics {
  return { activeTasks: 0, memoryBytes: "0", cpuPercent: 0, uptimeSeconds: "0" };
}

export const ProcessorMetrics: MessageFns<ProcessorMetrics> = {
  encode(message: ProcessorMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      writer.uint32(8).int32(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      writer.uint32(16).int64(message.memoryBytes);
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      writer.uint32(29).float(message.cpuPercent);
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      writer.uint32(32).int64(message.uptimeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeTasks = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryBytes = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.cpuPercent = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uptimeSeconds = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorMetrics {
    return {
      activeTasks: isSet(object.activeTasks) ? globalThis.Number(object.activeTasks) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      cpuPercent: isSet(object.cpuPercent) ? globalThis.Number(object.cpuPercent) : 0,
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
    };
  },

  toJSON(message: ProcessorMetrics): unknown {
    const obj: any = {};
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      obj.activeTasks = Math.round(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      obj.cpuPercent = message.cpuPercent;
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(base?: I): ProcessorMetrics {
    return ProcessorMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(object: I): ProcessorMetrics {
    const message = createBaseProcessorMetrics();
    message.activeTasks = object.activeTasks ?? 0;
    message.memoryBytes = object.memoryBytes ?? "0";
    message.cpuPercent = object.cpuPercent ?? 0;
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    return message;
  },
};

function createBaseWindowTypeRead(): WindowTypeRead {
  return {};
}

export const WindowTypeRead: MessageFns<WindowTypeRead> = {
  encode(_: WindowTypeRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypeRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypeRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WindowTypeRead {
    return {};
  },

  toJSON(_: WindowTypeRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypeRead>, I>>(base?: I): WindowTypeRead {
    return WindowTypeRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypeRead>, I>>(_: I): WindowTypeRead {
    const message = createBaseWindowTypeRead();
    return message;
  },
};

function createBaseWindowTypes(): WindowTypes {
  return { windows: [] };
}

export const WindowTypes: MessageFns<WindowTypes> = {
  encode(message: WindowTypes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.windows !== undefined && message.windows.length !== 0) {
      for (const v of message.windows) {
        WindowType.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowTypes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = WindowType.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.windows!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowTypes {
    return {
      windows: globalThis.Array.isArray(object?.windows) ? object.windows.map((e: any) => WindowType.fromJSON(e)) : [],
    };
  },

  toJSON(message: WindowTypes): unknown {
    const obj: any = {};
    if (message.windows?.length) {
      obj.windows = message.windows.map((e) => WindowType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowTypes>, I>>(base?: I): WindowTypes {
    return WindowTypes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowTypes>, I>>(object: I): WindowTypes {
    const message = createBaseWindowTypes();
    message.windows = object.windows?.map((e) => WindowType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlgorithmsRead(): AlgorithmsRead {
  return {};
}

export const AlgorithmsRead: MessageFns<AlgorithmsRead> = {
  encode(_: AlgorithmsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AlgorithmsRead {
    return {};
  },

  toJSON(_: AlgorithmsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmsRead>, I>>(base?: I): AlgorithmsRead {
    return AlgorithmsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmsRead>, I>>(_: I): AlgorithmsRead {
    const message = createBaseAlgorithmsRead();
    return message;
  },
};

function createBaseAlgorithms(): Algorithms {
  return { algorithm: [] };
}

export const Algorithms: MessageFns<Algorithms> = {
  encode(message: Algorithms, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined && message.algorithm.length !== 0) {
      for (const v of message.algorithm) {
        Algorithm.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithms {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithms();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithm!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithms {
    return {
      algorithm: globalThis.Array.isArray(object?.algorithm)
        ? object.algorithm.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Algorithms): unknown {
    const obj: any = {};
    if (message.algorithm?.length) {
      obj.algorithm = message.algorithm.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithms>, I>>(base?: I): Algorithms {
    return Algorithms.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithms>, I>>(object: I): Algorithms {
    const message = createBaseAlgorithms();
    message.algorithm = object.algorithm?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessorsRead(): ProcessorsRead {
  return {};
}

export const ProcessorsRead: MessageFns<ProcessorsRead> = {
  encode(_: ProcessorsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ProcessorsRead {
    return {};
  },

  toJSON(_: ProcessorsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorsRead>, I>>(base?: I): ProcessorsRead {
    return ProcessorsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorsRead>, I>>(_: I): ProcessorsRead {
    const message = createBaseProcessorsRead();
    return message;
  },
};

function createBaseProcessors(): Processors {
  return { processor: [] };
}

export const Processors: MessageFns<Processors> = {
  encode(message: Processors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processor !== undefined && message.processor.length !== 0) {
      for (const v of message.processor) {
        Processors_Processor.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Processors_Processor.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.processor!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processors {
    return {
      processor: globalThis.Array.isArray(object?.processor)
        ? object.processor.map((e: any) => Processors_Processor.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Processors): unknown {
    const obj: any = {};
    if (message.processor?.length) {
      obj.processor = message.processor.map((e) => Processors_Processor.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processors>, I>>(base?: I): Processors {
    return Processors.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processors>, I>>(object: I): Processors {
    const message = createBaseProcessors();
    message.processor = object.processor?.map((e) => Processors_Processor.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessors_Processor(): Processors_Processor {
  return { name: "", runtime: "" };
}

export const Processors_Processor: MessageFns<Processors_Processor> = {
  encode(message: Processors_Processor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processors_Processor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessors_Processor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Processors_Processor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
    };
  },

  toJSON(message: Processors_Processor): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Processors_Processor>, I>>(base?: I): Processors_Processor {
    return Processors_Processor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Processors_Processor>, I>>(object: I): Processors_Processor {
    const message = createBaseProcessors_Processor();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    return message;
  },
};

function createBaseResultsStatsRead(): ResultsStatsRead {
  return {};
}

export const ResultsStatsRead: MessageFns<ResultsStatsRead> = {
  encode(_: ResultsStatsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsStatsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsStatsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResultsStatsRead {
    return {};
  },

  toJSON(_: ResultsStatsRead): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsStatsRead>, I>>(base?: I): ResultsStatsRead {
    return ResultsStatsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsStatsRead>, I>>(_: I): ResultsStatsRead {
    const message = createBaseResultsStatsRead();
    return message;
  },
};

function createBaseResultsStats(): ResultsStats {
  return { Count: "0" };
}

export const ResultsStats: MessageFns<ResultsStats> = {
  encode(message: ResultsStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.Count !== undefined && message.Count !== "0") {
      writer.uint32(8).int64(message.Count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.Count = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsStats {
    return { Count: isSet(object.Count) ? globalThis.String(object.Count) : "0" };
  },

  toJSON(message: ResultsStats): unknown {
    const obj: any = {};
    if (message.Count !== undefined && message.Count !== "0") {
      obj.Count = message.Count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsStats>, I>>(base?: I): ResultsStats {
    return ResultsStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsStats>, I>>(object: I): ResultsStats {
    const message = createBaseResultsStats();
    message.Count = object.Count ?? "0";
    return message;
  },
};

function createBaseAlgorithmFieldsRead(): AlgorithmFieldsRead {
  return { timeFrom: undefined, timeTo: undefined, algorithm: undefined };
}

export const AlgorithmFieldsRead: MessageFns<AlgorithmFieldsRead> = {
  encode(message: AlgorithmFieldsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmFieldsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmFieldsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmFieldsRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
    };
  },

  toJSON(message: AlgorithmFieldsRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmFieldsRead>, I>>(base?: I): AlgorithmFieldsRead {
    return AlgorithmFieldsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmFieldsRead>, I>>(object: I): AlgorithmFieldsRead {
    const message = createBaseAlgorithmFieldsRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    return message;
  },
};

function createBaseAlgorithmFields(): AlgorithmFields {
  return { field: [] };
}

export const AlgorithmFields: MessageFns<AlgorithmFields> = {
  encode(message: AlgorithmFields, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined && message.field.length !== 0) {
      for (const v of message.field) {
        writer.uint32(10).string(v!);
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmFields {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = reader.string();
          if (el !== undefined) {
            message.field!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmFields {
    return { field: globalThis.Array.isArray(object?.field) ? object.field.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: AlgorithmFields): unknown {
    const obj: any = {};
    if (message.field?.length) {
      obj.field = message.field;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmFields>, I>>(base?: I): AlgorithmFields {
    return AlgorithmFields.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmFields>, I>>(object: I): AlgorithmFields {
    const message = createBaseAlgorithmFields();
    message.field = object.field?.map((e) => e) || [];
    return message;
  },
};

function createBaseResultsForAlgorithmRead(): ResultsForAlgorithmRead {
  return { timeFrom: undefined, timeTo: undefined, algorithm: undefined };
}

export const ResultsForAlgorithmRead: MessageFns<ResultsForAlgorithmRead> = {
  encode(message: ResultsForAlgorithmRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithmRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithmRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithmRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
    };
  },

  toJSON(message: ResultsForAlgorithmRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithmRead>, I>>(base?: I): ResultsForAlgorithmRead {
    return ResultsForAlgorithmRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithmRead>, I>>(object: I): ResultsForAlgorithmRead {
    const message = createBaseResultsForAlgorithmRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    return message;
  },
};

function createBaseResultsForAlgorithm(): ResultsForAlgorithm {
  return { results: [] };
}

export const ResultsForAlgorithm: MessageFns<ResultsForAlgorithm> = {
  encode(message: ResultsForAlgorithm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined && message.results.length !== 0) {
      for (const v of message.results) {
        ResultsForAlgorithm_ResultsRow.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = ResultsForAlgorithm_ResultsRow.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.results!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithm {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ResultsForAlgorithm_ResultsRow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResultsForAlgorithm): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ResultsForAlgorithm_ResultsRow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithm>, I>>(base?: I): ResultsForAlgorithm {
    return ResultsForAlgorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithm>, I>>(object: I): ResultsForAlgorithm {
    const message = createBaseResultsForAlgorithm();
    message.results = object.results?.map((e) => ResultsForAlgorithm_ResultsRow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResultsForAlgorithm_ResultsRow(): ResultsForAlgorithm_ResultsRow {
  return { time: undefined, resultData: undefined };
}

export const ResultsForAlgorithm_ResultsRow: MessageFns<ResultsForAlgorithm_ResultsRow> = {
  encode(message: ResultsForAlgorithm_ResultsRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    switch (message.resultData?.$case) {
      case "singleValue":
        writer.uint32(21).float(message.resultData.value);
        break;
      case "arrayValues":
        FloatArray.encode(message.resultData.value, writer.uint32(26).fork()).join();
        break;
      case "structValue":
        Struct.encode(Struct.wrap(message.resultData.value), writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithm_ResultsRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithm_ResultsRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.resultData = { $case: "singleValue", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultData = { $case: "arrayValues", value: FloatArray.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resultData = { $case: "structValue", value: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithm_ResultsRow {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      resultData: isSet(object.singleValue)
        ? { $case: "singleValue", value: globalThis.Number(object.singleValue) }
        : isSet(object.arrayValues)
        ? { $case: "arrayValues", value: FloatArray.fromJSON(object.arrayValues) }
        : isSet(object.structValue)
        ? { $case: "structValue", value: object.structValue }
        : undefined,
    };
  },

  toJSON(message: ResultsForAlgorithm_ResultsRow): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.resultData?.$case === "singleValue") {
      obj.singleValue = message.resultData.value;
    } else if (message.resultData?.$case === "arrayValues") {
      obj.arrayValues = FloatArray.toJSON(message.resultData.value);
    } else if (message.resultData?.$case === "structValue") {
      obj.structValue = message.resultData.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithm_ResultsRow>, I>>(base?: I): ResultsForAlgorithm_ResultsRow {
    return ResultsForAlgorithm_ResultsRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithm_ResultsRow>, I>>(
    object: I,
  ): ResultsForAlgorithm_ResultsRow {
    const message = createBaseResultsForAlgorithm_ResultsRow();
    message.time = object.time ?? undefined;
    switch (object.resultData?.$case) {
      case "singleValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "singleValue", value: object.resultData.value };
        }
        break;
      }
      case "arrayValues": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "arrayValues", value: FloatArray.fromPartial(object.resultData.value) };
        }
        break;
      }
      case "structValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "structValue", value: object.resultData.value };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseWindowsRead(): WindowsRead {
  return { timeFrom: undefined, timeTo: undefined, window: undefined };
}

export const WindowsRead: MessageFns<WindowsRead> = {
  encode(message: WindowsRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      WindowType.encode(message.window, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = WindowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      window: isSet(object.window) ? WindowType.fromJSON(object.window) : undefined,
    };
  },

  toJSON(message: WindowsRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.window !== undefined) {
      obj.window = WindowType.toJSON(message.window);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsRead>, I>>(base?: I): WindowsRead {
    return WindowsRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsRead>, I>>(object: I): WindowsRead {
    const message = createBaseWindowsRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? WindowType.fromPartial(object.window)
      : undefined;
    return message;
  },
};

function createBaseWindows(): Windows {
  return { window: [] };
}

export const Windows: MessageFns<Windows> = {
  encode(message: Windows, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined && message.window.length !== 0) {
      for (const v of message.window) {
        Window.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Windows {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindows();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Window.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.window!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Windows {
    return {
      window: globalThis.Array.isArray(object?.window) ? object.window.map((e: any) => Window.fromJSON(e)) : [],
    };
  },

  toJSON(message: Windows): unknown {
    const obj: any = {};
    if (message.window?.length) {
      obj.window = message.window.map((e) => Window.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Windows>, I>>(base?: I): Windows {
    return Windows.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Windows>, I>>(object: I): Windows {
    const message = createBaseWindows();
    message.window = object.window?.map((e) => Window.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDistinctMetadataForWindowTypeRead(): DistinctMetadataForWindowTypeRead {
  return { timeFrom: undefined, timeTo: undefined, windowType: undefined };
}

export const DistinctMetadataForWindowTypeRead: MessageFns<DistinctMetadataForWindowTypeRead> = {
  encode(message: DistinctMetadataForWindowTypeRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.windowType !== undefined) {
      WindowType.encode(message.windowType, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistinctMetadataForWindowTypeRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistinctMetadataForWindowTypeRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowType = WindowType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistinctMetadataForWindowTypeRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      windowType: isSet(object.windowType) ? WindowType.fromJSON(object.windowType) : undefined,
    };
  },

  toJSON(message: DistinctMetadataForWindowTypeRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.windowType !== undefined) {
      obj.windowType = WindowType.toJSON(message.windowType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistinctMetadataForWindowTypeRead>, I>>(
    base?: I,
  ): DistinctMetadataForWindowTypeRead {
    return DistinctMetadataForWindowTypeRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistinctMetadataForWindowTypeRead>, I>>(
    object: I,
  ): DistinctMetadataForWindowTypeRead {
    const message = createBaseDistinctMetadataForWindowTypeRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.windowType = (object.windowType !== undefined && object.windowType !== null)
      ? WindowType.fromPartial(object.windowType)
      : undefined;
    return message;
  },
};

function createBaseDistinctMetadataForWindowType(): DistinctMetadataForWindowType {
  return { metadata: undefined };
}

export const DistinctMetadataForWindowType: MessageFns<DistinctMetadataForWindowType> = {
  encode(message: DistinctMetadataForWindowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      ListValue.encode(ListValue.wrap(message.metadata), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistinctMetadataForWindowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistinctMetadataForWindowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DistinctMetadataForWindowType {
    return { metadata: globalThis.Array.isArray(object.metadata) ? [...object.metadata] : undefined };
  },

  toJSON(message: DistinctMetadataForWindowType): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DistinctMetadataForWindowType>, I>>(base?: I): DistinctMetadataForWindowType {
    return DistinctMetadataForWindowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DistinctMetadataForWindowType>, I>>(
    object: I,
  ): DistinctMetadataForWindowType {
    const message = createBaseDistinctMetadataForWindowType();
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseWindowsForMetadataRead(): WindowsForMetadataRead {
  return { timeFrom: undefined, timeTo: undefined, window: undefined, metadata: [] };
}

export const WindowsForMetadataRead: MessageFns<WindowsForMetadataRead> = {
  encode(message: WindowsForMetadataRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      WindowType.encode(message.window, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined && message.metadata.length !== 0) {
      for (const v of message.metadata) {
        WindowsForMetadataRead_Metadata.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsForMetadataRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsForMetadataRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = WindowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = WindowsForMetadataRead_Metadata.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadata!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsForMetadataRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      window: isSet(object.window) ? WindowType.fromJSON(object.window) : undefined,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => WindowsForMetadataRead_Metadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WindowsForMetadataRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.window !== undefined) {
      obj.window = WindowType.toJSON(message.window);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => WindowsForMetadataRead_Metadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsForMetadataRead>, I>>(base?: I): WindowsForMetadataRead {
    return WindowsForMetadataRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsForMetadataRead>, I>>(object: I): WindowsForMetadataRead {
    const message = createBaseWindowsForMetadataRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? WindowType.fromPartial(object.window)
      : undefined;
    message.metadata = object.metadata?.map((e) => WindowsForMetadataRead_Metadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWindowsForMetadataRead_Metadata(): WindowsForMetadataRead_Metadata {
  return { field: "", value: undefined };
}

export const WindowsForMetadataRead_Metadata: MessageFns<WindowsForMetadataRead_Metadata> = {
  encode(message: WindowsForMetadataRead_Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined && message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsForMetadataRead_Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsForMetadataRead_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsForMetadataRead_Metadata {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: WindowsForMetadataRead_Metadata): unknown {
    const obj: any = {};
    if (message.field !== undefined && message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsForMetadataRead_Metadata>, I>>(base?: I): WindowsForMetadataRead_Metadata {
    return WindowsForMetadataRead_Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsForMetadataRead_Metadata>, I>>(
    object: I,
  ): WindowsForMetadataRead_Metadata {
    const message = createBaseWindowsForMetadataRead_Metadata();
    message.field = object.field ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseWindowsForMetadata(): WindowsForMetadata {
  return { window: [] };
}

export const WindowsForMetadata: MessageFns<WindowsForMetadata> = {
  encode(message: WindowsForMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined && message.window.length !== 0) {
      for (const v of message.window) {
        Window.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsForMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsForMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = Window.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.window!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsForMetadata {
    return {
      window: globalThis.Array.isArray(object?.window) ? object.window.map((e: any) => Window.fromJSON(e)) : [],
    };
  },

  toJSON(message: WindowsForMetadata): unknown {
    const obj: any = {};
    if (message.window?.length) {
      obj.window = message.window.map((e) => Window.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowsForMetadata>, I>>(base?: I): WindowsForMetadata {
    return WindowsForMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowsForMetadata>, I>>(object: I): WindowsForMetadata {
    const message = createBaseWindowsForMetadata();
    message.window = object.window?.map((e) => Window.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResultsForAlgorithmAndMetadataRead(): ResultsForAlgorithmAndMetadataRead {
  return { timeFrom: undefined, timeTo: undefined, algorithm: undefined, metadata: [] };
}

export const ResultsForAlgorithmAndMetadataRead: MessageFns<ResultsForAlgorithmAndMetadataRead> = {
  encode(message: ResultsForAlgorithmAndMetadataRead, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined && message.metadata.length !== 0) {
      for (const v of message.metadata) {
        ResultsForAlgorithmAndMetadataRead_Metadata.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithmAndMetadataRead {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithmAndMetadataRead();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = ResultsForAlgorithmAndMetadataRead_Metadata.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadata!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithmAndMetadataRead {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => ResultsForAlgorithmAndMetadataRead_Metadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResultsForAlgorithmAndMetadataRead): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => ResultsForAlgorithmAndMetadataRead_Metadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadataRead>, I>>(
    base?: I,
  ): ResultsForAlgorithmAndMetadataRead {
    return ResultsForAlgorithmAndMetadataRead.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadataRead>, I>>(
    object: I,
  ): ResultsForAlgorithmAndMetadataRead {
    const message = createBaseResultsForAlgorithmAndMetadataRead();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.metadata = object.metadata?.map((e) => ResultsForAlgorithmAndMetadataRead_Metadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResultsForAlgorithmAndMetadataRead_Metadata(): ResultsForAlgorithmAndMetadataRead_Metadata {
  return { field: "", value: undefined };
}

export const ResultsForAlgorithmAndMetadataRead_Metadata: MessageFns<ResultsForAlgorithmAndMetadataRead_Metadata> = {
  encode(
    message: ResultsForAlgorithmAndMetadataRead_Metadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.field !== undefined && message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithmAndMetadataRead_Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithmAndMetadataRead_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithmAndMetadataRead_Metadata {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: ResultsForAlgorithmAndMetadataRead_Metadata): unknown {
    const obj: any = {};
    if (message.field !== undefined && message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadataRead_Metadata>, I>>(
    base?: I,
  ): ResultsForAlgorithmAndMetadataRead_Metadata {
    return ResultsForAlgorithmAndMetadataRead_Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadataRead_Metadata>, I>>(
    object: I,
  ): ResultsForAlgorithmAndMetadataRead_Metadata {
    const message = createBaseResultsForAlgorithmAndMetadataRead_Metadata();
    message.field = object.field ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseResultsForAlgorithmAndMetadata(): ResultsForAlgorithmAndMetadata {
  return { results: [] };
}

export const ResultsForAlgorithmAndMetadata: MessageFns<ResultsForAlgorithmAndMetadata> = {
  encode(message: ResultsForAlgorithmAndMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.results !== undefined && message.results.length !== 0) {
      for (const v of message.results) {
        ResultsForAlgorithmAndMetadata_ResultsRow.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithmAndMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithmAndMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = ResultsForAlgorithmAndMetadata_ResultsRow.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.results!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithmAndMetadata {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => ResultsForAlgorithmAndMetadata_ResultsRow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResultsForAlgorithmAndMetadata): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => ResultsForAlgorithmAndMetadata_ResultsRow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadata>, I>>(base?: I): ResultsForAlgorithmAndMetadata {
    return ResultsForAlgorithmAndMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadata>, I>>(
    object: I,
  ): ResultsForAlgorithmAndMetadata {
    const message = createBaseResultsForAlgorithmAndMetadata();
    message.results = object.results?.map((e) => ResultsForAlgorithmAndMetadata_ResultsRow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResultsForAlgorithmAndMetadata_ResultsRow(): ResultsForAlgorithmAndMetadata_ResultsRow {
  return { time: undefined, resultData: undefined };
}

export const ResultsForAlgorithmAndMetadata_ResultsRow: MessageFns<ResultsForAlgorithmAndMetadata_ResultsRow> = {
  encode(message: ResultsForAlgorithmAndMetadata_ResultsRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    switch (message.resultData?.$case) {
      case "singleValue":
        writer.uint32(21).float(message.resultData.value);
        break;
      case "arrayValues":
        FloatArray.encode(message.resultData.value, writer.uint32(26).fork()).join();
        break;
      case "structValue":
        Struct.encode(Struct.wrap(message.resultData.value), writer.uint32(34).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResultsForAlgorithmAndMetadata_ResultsRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResultsForAlgorithmAndMetadata_ResultsRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.resultData = { $case: "singleValue", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultData = { $case: "arrayValues", value: FloatArray.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resultData = { $case: "structValue", value: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResultsForAlgorithmAndMetadata_ResultsRow {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      resultData: isSet(object.singleValue)
        ? { $case: "singleValue", value: globalThis.Number(object.singleValue) }
        : isSet(object.arrayValues)
        ? { $case: "arrayValues", value: FloatArray.fromJSON(object.arrayValues) }
        : isSet(object.structValue)
        ? { $case: "structValue", value: object.structValue }
        : undefined,
    };
  },

  toJSON(message: ResultsForAlgorithmAndMetadata_ResultsRow): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.resultData?.$case === "singleValue") {
      obj.singleValue = message.resultData.value;
    } else if (message.resultData?.$case === "arrayValues") {
      obj.arrayValues = FloatArray.toJSON(message.resultData.value);
    } else if (message.resultData?.$case === "structValue") {
      obj.structValue = message.resultData.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadata_ResultsRow>, I>>(
    base?: I,
  ): ResultsForAlgorithmAndMetadata_ResultsRow {
    return ResultsForAlgorithmAndMetadata_ResultsRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResultsForAlgorithmAndMetadata_ResultsRow>, I>>(
    object: I,
  ): ResultsForAlgorithmAndMetadata_ResultsRow {
    const message = createBaseResultsForAlgorithmAndMetadata_ResultsRow();
    message.time = object.time ?? undefined;
    switch (object.resultData?.$case) {
      case "singleValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "singleValue", value: object.resultData.value };
        }
        break;
      }
      case "arrayValues": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "arrayValues", value: FloatArray.fromPartial(object.resultData.value) };
        }
        break;
      }
      case "structValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "structValue", value: object.resultData.value };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAnnotateWrite(): AnnotateWrite {
  return {
    timeFrom: undefined,
    timeTo: undefined,
    capturedAlgorithms: [],
    capturedWindows: [],
    description: "",
    metadata: undefined,
  };
}

export const AnnotateWrite: MessageFns<AnnotateWrite> = {
  encode(message: AnnotateWrite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.capturedAlgorithms !== undefined && message.capturedAlgorithms.length !== 0) {
      for (const v of message.capturedAlgorithms) {
        Algorithm.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.capturedWindows !== undefined && message.capturedWindows.length !== 0) {
      for (const v of message.capturedWindows) {
        WindowType.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateWrite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateWrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.capturedAlgorithms!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = WindowType.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.capturedWindows!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotateWrite {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      capturedAlgorithms: globalThis.Array.isArray(object?.capturedAlgorithms)
        ? object.capturedAlgorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
      capturedWindows: globalThis.Array.isArray(object?.capturedWindows)
        ? object.capturedWindows.map((e: any) => WindowType.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: AnnotateWrite): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.capturedAlgorithms?.length) {
      obj.capturedAlgorithms = message.capturedAlgorithms.map((e) => Algorithm.toJSON(e));
    }
    if (message.capturedWindows?.length) {
      obj.capturedWindows = message.capturedWindows.map((e) => WindowType.toJSON(e));
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotateWrite>, I>>(base?: I): AnnotateWrite {
    return AnnotateWrite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotateWrite>, I>>(object: I): AnnotateWrite {
    const message = createBaseAnnotateWrite();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.capturedAlgorithms = object.capturedAlgorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    message.capturedWindows = object.capturedWindows?.map((e) => WindowType.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseAnnotateResponse(): AnnotateResponse {
  return {};
}

export const AnnotateResponse: MessageFns<AnnotateResponse> = {
  encode(_: AnnotateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AnnotateResponse {
    return {};
  },

  toJSON(_: AnnotateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotateResponse>, I>>(base?: I): AnnotateResponse {
    return AnnotateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotateResponse>, I>>(_: I): AnnotateResponse {
    const message = createBaseAnnotateResponse();
    return message;
  },
};

/**
 * OrcaCore is the central orchestration service that:
 * - Manages the lifecycle of processing windows
 * - Coordinates algorithm execution across distributed processors
 * - Tracks DAG dependencies and execution state
 * - Routes results between dependent algorithms
 */
export type OrcaCoreService = typeof OrcaCoreService;
export const OrcaCoreService = {
  /** Register a processor node and its supported algorithms */
  registerProcessor: {
    path: "/OrcaCore/RegisterProcessor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessorRegistration): Buffer =>
      Buffer.from(ProcessorRegistration.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessorRegistration => ProcessorRegistration.decode(value),
    responseSerialize: (value: Status): Buffer => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer): Status => Status.decode(value),
  },
  /** Submit a window for processing */
  emitWindow: {
    path: "/OrcaCore/EmitWindow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Window): Buffer => Buffer.from(Window.encode(value).finish()),
    requestDeserialize: (value: Buffer): Window => Window.decode(value),
    responseSerialize: (value: WindowEmitStatus): Buffer => Buffer.from(WindowEmitStatus.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowEmitStatus => WindowEmitStatus.decode(value),
  },
  /** ------------------- Data operations ------------------- */
  readWindowTypes: {
    path: "/OrcaCore/ReadWindowTypes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WindowTypeRead): Buffer => Buffer.from(WindowTypeRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): WindowTypeRead => WindowTypeRead.decode(value),
    responseSerialize: (value: WindowTypes): Buffer => Buffer.from(WindowTypes.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowTypes => WindowTypes.decode(value),
  },
  readAlgorithms: {
    path: "/OrcaCore/ReadAlgorithms",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AlgorithmsRead): Buffer => Buffer.from(AlgorithmsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): AlgorithmsRead => AlgorithmsRead.decode(value),
    responseSerialize: (value: Algorithms): Buffer => Buffer.from(Algorithms.encode(value).finish()),
    responseDeserialize: (value: Buffer): Algorithms => Algorithms.decode(value),
  },
  readProcessors: {
    path: "/OrcaCore/ReadProcessors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessorsRead): Buffer => Buffer.from(ProcessorsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessorsRead => ProcessorsRead.decode(value),
    responseSerialize: (value: Processors): Buffer => Buffer.from(Processors.encode(value).finish()),
    responseDeserialize: (value: Buffer): Processors => Processors.decode(value),
  },
  readResultsStats: {
    path: "/OrcaCore/ReadResultsStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResultsStatsRead): Buffer => Buffer.from(ResultsStatsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResultsStatsRead => ResultsStatsRead.decode(value),
    responseSerialize: (value: ResultsStats): Buffer => Buffer.from(ResultsStats.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResultsStats => ResultsStats.decode(value),
  },
  readResultFieldsForAlgorithm: {
    path: "/OrcaCore/ReadResultFieldsForAlgorithm",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AlgorithmFieldsRead): Buffer => Buffer.from(AlgorithmFieldsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): AlgorithmFieldsRead => AlgorithmFieldsRead.decode(value),
    responseSerialize: (value: AlgorithmFields): Buffer => Buffer.from(AlgorithmFields.encode(value).finish()),
    responseDeserialize: (value: Buffer): AlgorithmFields => AlgorithmFields.decode(value),
  },
  readResultsForAlgorithm: {
    path: "/OrcaCore/ReadResultsForAlgorithm",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResultsForAlgorithmRead): Buffer =>
      Buffer.from(ResultsForAlgorithmRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResultsForAlgorithmRead => ResultsForAlgorithmRead.decode(value),
    responseSerialize: (value: ResultsForAlgorithm): Buffer => Buffer.from(ResultsForAlgorithm.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResultsForAlgorithm => ResultsForAlgorithm.decode(value),
  },
  readWindows: {
    path: "/OrcaCore/ReadWindows",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WindowsRead): Buffer => Buffer.from(WindowsRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): WindowsRead => WindowsRead.decode(value),
    responseSerialize: (value: Windows): Buffer => Buffer.from(Windows.encode(value).finish()),
    responseDeserialize: (value: Buffer): Windows => Windows.decode(value),
  },
  readDistinctMetadataForWindowType: {
    path: "/OrcaCore/ReadDistinctMetadataForWindowType",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DistinctMetadataForWindowTypeRead): Buffer =>
      Buffer.from(DistinctMetadataForWindowTypeRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): DistinctMetadataForWindowTypeRead =>
      DistinctMetadataForWindowTypeRead.decode(value),
    responseSerialize: (value: DistinctMetadataForWindowType): Buffer =>
      Buffer.from(DistinctMetadataForWindowType.encode(value).finish()),
    responseDeserialize: (value: Buffer): DistinctMetadataForWindowType => DistinctMetadataForWindowType.decode(value),
  },
  readWindowsForMetadata: {
    path: "/OrcaCore/ReadWindowsForMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WindowsForMetadataRead): Buffer =>
      Buffer.from(WindowsForMetadataRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): WindowsForMetadataRead => WindowsForMetadataRead.decode(value),
    responseSerialize: (value: WindowsForMetadata): Buffer => Buffer.from(WindowsForMetadata.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowsForMetadata => WindowsForMetadata.decode(value),
  },
  readResultsForAlgorithmAndMetadata: {
    path: "/OrcaCore/ReadResultsForAlgorithmAndMetadata",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResultsForAlgorithmAndMetadataRead): Buffer =>
      Buffer.from(ResultsForAlgorithmAndMetadataRead.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResultsForAlgorithmAndMetadataRead =>
      ResultsForAlgorithmAndMetadataRead.decode(value),
    responseSerialize: (value: ResultsForAlgorithmAndMetadata): Buffer =>
      Buffer.from(ResultsForAlgorithmAndMetadata.encode(value).finish()),
    responseDeserialize: (value: Buffer): ResultsForAlgorithmAndMetadata =>
      ResultsForAlgorithmAndMetadata.decode(value),
  },
  /** ------------------ Annotation operations ----------------- */
  annotate: {
    path: "/OrcaCore/Annotate",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AnnotateWrite): Buffer => Buffer.from(AnnotateWrite.encode(value).finish()),
    requestDeserialize: (value: Buffer): AnnotateWrite => AnnotateWrite.decode(value),
    responseSerialize: (value: AnnotateResponse): Buffer => Buffer.from(AnnotateResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): AnnotateResponse => AnnotateResponse.decode(value),
  },
} as const;

export interface OrcaCoreServer extends UntypedServiceImplementation {
  /** Register a processor node and its supported algorithms */
  registerProcessor: handleUnaryCall<ProcessorRegistration, Status>;
  /** Submit a window for processing */
  emitWindow: handleUnaryCall<Window, WindowEmitStatus>;
  /** ------------------- Data operations ------------------- */
  readWindowTypes: handleUnaryCall<WindowTypeRead, WindowTypes>;
  readAlgorithms: handleUnaryCall<AlgorithmsRead, Algorithms>;
  readProcessors: handleUnaryCall<ProcessorsRead, Processors>;
  readResultsStats: handleUnaryCall<ResultsStatsRead, ResultsStats>;
  readResultFieldsForAlgorithm: handleUnaryCall<AlgorithmFieldsRead, AlgorithmFields>;
  readResultsForAlgorithm: handleUnaryCall<ResultsForAlgorithmRead, ResultsForAlgorithm>;
  readWindows: handleUnaryCall<WindowsRead, Windows>;
  readDistinctMetadataForWindowType: handleUnaryCall<DistinctMetadataForWindowTypeRead, DistinctMetadataForWindowType>;
  readWindowsForMetadata: handleUnaryCall<WindowsForMetadataRead, WindowsForMetadata>;
  readResultsForAlgorithmAndMetadata: handleUnaryCall<
    ResultsForAlgorithmAndMetadataRead,
    ResultsForAlgorithmAndMetadata
  >;
  /** ------------------ Annotation operations ----------------- */
  annotate: handleUnaryCall<AnnotateWrite, AnnotateResponse>;
}

export interface OrcaCoreClient extends Client {
  /** Register a processor node and its supported algorithms */
  registerProcessor(
    request: ProcessorRegistration,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  /** Submit a window for processing */
  emitWindow(
    request: Window,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  /** ------------------- Data operations ------------------- */
  readWindowTypes(
    request: WindowTypeRead,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readWindowTypes(
    request: WindowTypeRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readWindowTypes(
    request: WindowTypeRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowTypes) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readAlgorithms(
    request: AlgorithmsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Algorithms) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readProcessors(
    request: ProcessorsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Processors) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
  readResultsStats(
    request: ResultsStatsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResultsStats) => void,
  ): ClientUnaryCall;
  readResultFieldsForAlgorithm(
    request: AlgorithmFieldsRead,
    callback: (error: ServiceError | null, response: AlgorithmFields) => void,
  ): ClientUnaryCall;
  readResultFieldsForAlgorithm(
    request: AlgorithmFieldsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AlgorithmFields) => void,
  ): ClientUnaryCall;
  readResultFieldsForAlgorithm(
    request: AlgorithmFieldsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AlgorithmFields) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithm(
    request: ResultsForAlgorithmRead,
    callback: (error: ServiceError | null, response: ResultsForAlgorithm) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithm(
    request: ResultsForAlgorithmRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResultsForAlgorithm) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithm(
    request: ResultsForAlgorithmRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResultsForAlgorithm) => void,
  ): ClientUnaryCall;
  readWindows(request: WindowsRead, callback: (error: ServiceError | null, response: Windows) => void): ClientUnaryCall;
  readWindows(
    request: WindowsRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Windows) => void,
  ): ClientUnaryCall;
  readWindows(
    request: WindowsRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Windows) => void,
  ): ClientUnaryCall;
  readDistinctMetadataForWindowType(
    request: DistinctMetadataForWindowTypeRead,
    callback: (error: ServiceError | null, response: DistinctMetadataForWindowType) => void,
  ): ClientUnaryCall;
  readDistinctMetadataForWindowType(
    request: DistinctMetadataForWindowTypeRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DistinctMetadataForWindowType) => void,
  ): ClientUnaryCall;
  readDistinctMetadataForWindowType(
    request: DistinctMetadataForWindowTypeRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DistinctMetadataForWindowType) => void,
  ): ClientUnaryCall;
  readWindowsForMetadata(
    request: WindowsForMetadataRead,
    callback: (error: ServiceError | null, response: WindowsForMetadata) => void,
  ): ClientUnaryCall;
  readWindowsForMetadata(
    request: WindowsForMetadataRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowsForMetadata) => void,
  ): ClientUnaryCall;
  readWindowsForMetadata(
    request: WindowsForMetadataRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowsForMetadata) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithmAndMetadata(
    request: ResultsForAlgorithmAndMetadataRead,
    callback: (error: ServiceError | null, response: ResultsForAlgorithmAndMetadata) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithmAndMetadata(
    request: ResultsForAlgorithmAndMetadataRead,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ResultsForAlgorithmAndMetadata) => void,
  ): ClientUnaryCall;
  readResultsForAlgorithmAndMetadata(
    request: ResultsForAlgorithmAndMetadataRead,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ResultsForAlgorithmAndMetadata) => void,
  ): ClientUnaryCall;
  /** ------------------ Annotation operations ----------------- */
  annotate(
    request: AnnotateWrite,
    callback: (error: ServiceError | null, response: AnnotateResponse) => void,
  ): ClientUnaryCall;
  annotate(
    request: AnnotateWrite,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AnnotateResponse) => void,
  ): ClientUnaryCall;
  annotate(
    request: AnnotateWrite,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AnnotateResponse) => void,
  ): ClientUnaryCall;
}

export const OrcaCoreClient = makeGenericClientConstructor(OrcaCoreService, "OrcaCore") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaCoreClient;
  service: typeof OrcaCoreService;
  serviceName: string;
};

/**
 * OrcaProcessor defines the interface that each processing node must implement.
 * Processors are language-agnostic services that:
 * - Execute individual algorithms
 * - Handle their own internal state
 * - Report results back to the orchestrator
 * Orca will schedule processors asynchronously as per the DAG
 */
export type OrcaProcessorService = typeof OrcaProcessorService;
export const OrcaProcessorService = {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: {
    path: "/OrcaProcessor/ExecuteDagPart",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExecutionRequest): Buffer => Buffer.from(ExecutionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecutionRequest => ExecutionRequest.decode(value),
    responseSerialize: (value: ExecutionResult): Buffer => Buffer.from(ExecutionResult.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecutionResult => ExecutionResult.decode(value),
  },
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: {
    path: "/OrcaProcessor/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface OrcaProcessorServer extends UntypedServiceImplementation {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: handleServerStreamingCall<ExecutionRequest, ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface OrcaProcessorClient extends Client {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart(request: ExecutionRequest, options?: Partial<CallOptions>): ClientReadableStream<ExecutionResult>;
  executeDagPart(
    request: ExecutionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const OrcaProcessorClient = makeGenericClientConstructor(OrcaProcessorService, "OrcaProcessor") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaProcessorClient;
  service: typeof OrcaProcessorService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
