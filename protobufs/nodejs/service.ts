// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "";

export enum ResultType {
  /** NOT_SPECIFIED - placeholder sentinel to make explicit that nothing was provided */
  NOT_SPECIFIED = 0,
  /** STRUCT - the algorithm produces a struct result */
  STRUCT = 1,
  /** VALUE - the algorithm produces a single value */
  VALUE = 2,
  /** ARRAY - the algorithm produces an array of values */
  ARRAY = 3,
  /** NONE - the algorithm does not produce a result */
  NONE = 4,
  UNRECOGNIZED = -1,
}

export function resultTypeFromJSON(object: any): ResultType {
  switch (object) {
    case 0:
    case "NOT_SPECIFIED":
      return ResultType.NOT_SPECIFIED;
    case 1:
    case "STRUCT":
      return ResultType.STRUCT;
    case 2:
    case "VALUE":
      return ResultType.VALUE;
    case 3:
    case "ARRAY":
      return ResultType.ARRAY;
    case 4:
    case "NONE":
      return ResultType.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultType.UNRECOGNIZED;
  }
}

export function resultTypeToJSON(object: ResultType): string {
  switch (object) {
    case ResultType.NOT_SPECIFIED:
      return "NOT_SPECIFIED";
    case ResultType.STRUCT:
      return "STRUCT";
    case ResultType.VALUE:
      return "VALUE";
    case ResultType.ARRAY:
      return "ARRAY";
    case ResultType.NONE:
      return "NONE";
    case ResultType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ResultStatus indicates the outcome of algorithm execution */
export enum ResultStatus {
  /**
   * RESULT_STATUS_HANDLED_FAILED - Algorithm failed but the error was handled gracefully
   * The system may retry or skip depending on configuration
   */
  RESULT_STATUS_HANDLED_FAILED = 0,
  /**
   * RESULT_STATUS_UNHANDLED_FAILED - Algorithm failed with an unexpected error
   * Requires investigation and may halt dependent processing
   */
  RESULT_STATUS_UNHANDLED_FAILED = 1,
  /**
   * RESULT_STATUS_SUCEEDED - Algorithm completed successfully
   * Results are valid and can be used by dependent algorithms
   */
  RESULT_STATUS_SUCEEDED = 2,
  UNRECOGNIZED = -1,
}

export function resultStatusFromJSON(object: any): ResultStatus {
  switch (object) {
    case 0:
    case "RESULT_STATUS_HANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_HANDLED_FAILED;
    case 1:
    case "RESULT_STATUS_UNHANDLED_FAILED":
      return ResultStatus.RESULT_STATUS_UNHANDLED_FAILED;
    case 2:
    case "RESULT_STATUS_SUCEEDED":
      return ResultStatus.RESULT_STATUS_SUCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResultStatus.UNRECOGNIZED;
  }
}

export function resultStatusToJSON(object: ResultStatus): string {
  switch (object) {
    case ResultStatus.RESULT_STATUS_HANDLED_FAILED:
      return "RESULT_STATUS_HANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_UNHANDLED_FAILED:
      return "RESULT_STATUS_UNHANDLED_FAILED";
    case ResultStatus.RESULT_STATUS_SUCEEDED:
      return "RESULT_STATUS_SUCEEDED";
    case ResultStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ExposeSettings provides optional settings to the `Expose` procedure */
export interface ExposeSettings {
  excludeProject?: string | undefined;
}

/** Window represents a time-bounded processing context that triggers algorithm execution. Windows are the primary input that start DAG processing flows. */
export interface Window {
  /**
   * Time that the window starts - nanoseconds since epoch
   * Required: Must be > Unix epoch (1970-01-01T00:00:00Z)
   */
  timeFrom?:
    | Date
    | undefined;
  /**
   * Time that the window ends - nanoseconds since epoch
   * Required: Must be > time_from (validated at message level)
   */
  timeTo?:
    | Date
    | undefined;
  /** The canonical name of the window that uniquely identifies it */
  windowTypeName?:
    | string
    | undefined;
  /** The version of the window type */
  windowTypeVersion?:
    | string
    | undefined;
  /** A unique identifier that defines where the window came from */
  origin?:
    | string
    | undefined;
  /**
   * Additional metadata to attach to this window
   * The schema of this metadata is determined by the combination of
   * window_type_name and window_type_version. Each window type version
   * defines its own required and optional metadata fields, as defined
   * at the time of registration.
   */
  metadata?: { [key: string]: any } | undefined;
}

/** MetadataField describes the metadata that can be carried along with windows */
export interface MetadataField {
  /**
   * Name of the metadata field
   * Examples: "AssetID"
   */
  name?:
    | string
    | undefined;
  /**
   * Description of the field
   * Examples: "Unique ID of the asset"
   */
  description?: string | undefined;
}

/**
 * WindowType defines a category of window that can trigger algorithms.
 * Algorithms subscribe to window types to indicate when they should be executed.
 */
export interface WindowType {
  /**
   * Name of the window type - must be globally unique
   * Examples: "daily", "hourly", "market_close", "event_triggered"
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm. Follows basic semver and allows window
   * types to be changed over time, with traceability
   */
  version?:
    | string
    | undefined;
  /**
   * Description of the window
   * E.g. "Emitted every day, at noon"
   */
  description?:
    | string
    | undefined;
  /** Metadata fields that are carried along with this window type */
  metadataFields?: MetadataField[] | undefined;
}

/** WindowEmitStatus status message returned after emitting a window */
export interface WindowEmitStatus {
  status?: WindowEmitStatus_StatusEnum | undefined;
}

/** A status enum that captures scenarios regarding a window being emmited */
export enum WindowEmitStatus_StatusEnum {
  /** TRIGGERING_FAILED - When triggering has failed */
  TRIGGERING_FAILED = 0,
  /** NO_TRIGGERED_ALGORITHMS - When no algorithms could be found that are triggered by this window */
  NO_TRIGGERED_ALGORITHMS = 1,
  /** PROCESSING_TRIGGERED - When processing has successfully been triggered */
  PROCESSING_TRIGGERED = 2,
  UNRECOGNIZED = -1,
}

export function windowEmitStatus_StatusEnumFromJSON(object: any): WindowEmitStatus_StatusEnum {
  switch (object) {
    case 0:
    case "TRIGGERING_FAILED":
      return WindowEmitStatus_StatusEnum.TRIGGERING_FAILED;
    case 1:
    case "NO_TRIGGERED_ALGORITHMS":
      return WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS;
    case 2:
    case "PROCESSING_TRIGGERED":
      return WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowEmitStatus_StatusEnum.UNRECOGNIZED;
  }
}

export function windowEmitStatus_StatusEnumToJSON(object: WindowEmitStatus_StatusEnum): string {
  switch (object) {
    case WindowEmitStatus_StatusEnum.TRIGGERING_FAILED:
      return "TRIGGERING_FAILED";
    case WindowEmitStatus_StatusEnum.NO_TRIGGERED_ALGORITHMS:
      return "NO_TRIGGERED_ALGORITHMS";
    case WindowEmitStatus_StatusEnum.PROCESSING_TRIGGERED:
      return "PROCESSING_TRIGGERED";
    case WindowEmitStatus_StatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AlgorithmDependency defines a requirement that one algorithm has on another's results.
 * These dependencies form the edges in the processing DAG.
 */
export interface AlgorithmDependency {
  /**
   * Name of the required algorithm
   * Must reference an existing algorithm name in the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the required algorithm
   * Must follow semantic versioning (e.g., "1.0.0")
   */
  version?:
    | string
    | undefined;
  /** Name of the processor that the algorithm is associated with */
  processorName?:
    | string
    | undefined;
  /** Runtime of the processor that the algorithm is associated with */
  processorRuntime?:
    | string
    | undefined;
  /**
   * A lookback field that specifies whether this dependency
   * depends on past results of this algorithm
   */
  lookback?:
    | //
    /** Number of past results to depend on (if at all) */
    { $case: "lookbackNum"; value: number }
    | //
    /** Timeframe of past results to depend on (in milliseconds) */
    { $case: "lookbackTimeDelta"; value: string }
    | undefined;
}

/**
 * Algorithm defines a processing unit that can be executed by processors.
 * Algorithms form the nodes in the processing DAG and are triggered by specific window types.
 */
export interface Algorithm {
  /**
   * Name of the algorithm - must be globally unique
   * This identifies the algorithm across the system
   */
  name?:
    | string
    | undefined;
  /**
   * Version of the algorithm - must follow semantic versioning
   * Allows for algorithm evolution while maintaining compatibility
   */
  version?:
    | string
    | undefined;
  /**
   * Type of window that triggers this algorithm
   * References a WindowType that will cause this algorithm to execute
   */
  windowType?:
    | WindowType
    | undefined;
  /**
   * Other algorithms that this algorithm depends on
   * The algorithm won't execute until all dependencies have completed
   * Dependencies must not form cycles - this is statically checked on processor registration
   */
  dependencies?:
    | AlgorithmDependency[]
    | undefined;
  /**
   * The type of result that the algorithm produces. This is specified upfront
   * rather than introspected, to allow for validation
   */
  resultType?:
    | ResultType
    | undefined;
  /** A freeform description of the algorithm */
  description?: string | undefined;
}

/** Container for array of float values */
export interface FloatArray {
  values?: number[] | undefined;
}

/** Result of an algorithm execution */
export interface Result {
  /** Status of the result execution */
  status?:
    | ResultStatus
    | undefined;
  /** The actual result data - can be either an array of floats or a structured object */
  resultData?:
    | //
    /** for single number results */
    { $case: "singleValue"; value: number }
    | //
    /** For numeric array results */
    { $case: "floatValues"; value: FloatArray }
    | //
    /**
     * For structured data results (JSON-like)
     * Must follow a map<string, value> schema where value corresponds to https://protobuf.dev/reference/protobuf/google.protobuf/#value
     */
    { $case: "structValue"; value: { [key: string]: any } | undefined }
    | undefined;
  /** Timestamp when the result was produced */
  timestamp?: string | undefined;
}

/**
 * ProcessorRegistration is sent by processors when they start up to announce their capabilities
 * to the orchestrator. This establishes a long-lived connection for receiving tasks.
 */
export interface ProcessorRegistration {
  /** Unique name of the runtime */
  name?:
    | string
    | undefined;
  /**
   * Language/runtime of the processor
   * Examples: "python3.9", "go1.19", "Rust4.1"
   */
  runtime?:
    | string
    | undefined;
  /**
   * The connection string of the processor
   * e.g. grpc://localhost:5433
   */
  connectionStr?:
    | string
    | undefined;
  /**
   * Algorithms this processor can execute
   * The processor must implement all listed algorithms
   */
  supportedAlgorithms?:
    | Algorithm[]
    | undefined;
  /**
   * A name that can be attached to a group of processors. Describes the project in which
   * they are defined (typically a single git repository)
   */
  projectName?: string | undefined;
}

/**
 * ProcessingTask represents a single algorithm execution request sent to a processor.
 * Tasks are streamed to processors as their dependencies are satisfied.
 */
export interface ProcessingTask {
  /**
   * Unique ID for this specific task execution
   * Used to correlate results and track execution state
   */
  taskId?:
    | string
    | undefined;
  /**
   * Algorithm to execute
   * Must be one of the algorithms the processor registered support for
   */
  algorithm?:
    | Algorithm
    | undefined;
  /**
   * Window that triggered this task
   * Provides the time context for the algorithm execution
   */
  window?:
    | Window
    | undefined;
  /**
   * Results from dependent algorithms
   * Contains all results that this algorithm declared dependencies on
   * All dependencies will be present when task is sent
   */
  dependencyResults?: Result[] | undefined;
}

/**
 * ExecutionRequest provides a complete view of a processing DAG's execution
 * status for a specific window. Used for monitoring and debugging.
 */
export interface ExecutionRequest {
  /** The exec_id */
  execId?:
    | string
    | undefined;
  /** The window that triggered the algorithm */
  window?:
    | Window
    | undefined;
  /** Results from dependant algorithms */
  algorithmResults?:
    | AlgorithmResult[]
    | undefined;
  /** The algorithms to execute */
  algorithms?: Algorithm[] | undefined;
}

export interface ExecutionResult {
  /** Exec ID */
  execId?:
    | string
    | undefined;
  /** The algorithn result */
  algorithmResult?: AlgorithmResult | undefined;
}

/** AlgorithmWindowResult Packaged algorithm and result to a window */
export interface AlgorithmResult {
  algorithm?: Algorithm | undefined;
  result?: Result | undefined;
}

export interface Status {
  received?: boolean | undefined;
  message?: string | undefined;
}

/** HealthCheckRequest is sent to processors to verify they are functioning */
export interface HealthCheckRequest {
  /**
   * Timestamp of the request in unix epoch milliseconds
   * Used to measure response latency
   */
  timestamp?: string | undefined;
}

/** HealthCheckResponse indicates the health status of a processor */
export interface HealthCheckResponse {
  /** Current health status */
  status?:
    | HealthCheckResponse_Status
    | undefined;
  /** Optional message providing more detail about the health status */
  message?:
    | string
    | undefined;
  /** System metrics about the processor */
  metrics?: ProcessorMetrics | undefined;
}

/** Overall health status of the processor */
export enum HealthCheckResponse_Status {
  /** STATUS_UNKNOWN - Unknown status - should never be used */
  STATUS_UNKNOWN = 0,
  /** STATUS_SERVING - Processor is healthy and ready to accept tasks */
  STATUS_SERVING = 1,
  /** STATUS_TRANSITIONING - Processor is starting up or shutting down */
  STATUS_TRANSITIONING = 2,
  /** STATUS_NOT_SERVING - Processor is not healthy and cannot accept tasks */
  STATUS_NOT_SERVING = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_StatusFromJSON(object: any): HealthCheckResponse_Status {
  switch (object) {
    case 0:
    case "STATUS_UNKNOWN":
      return HealthCheckResponse_Status.STATUS_UNKNOWN;
    case 1:
    case "STATUS_SERVING":
      return HealthCheckResponse_Status.STATUS_SERVING;
    case 2:
    case "STATUS_TRANSITIONING":
      return HealthCheckResponse_Status.STATUS_TRANSITIONING;
    case 3:
    case "STATUS_NOT_SERVING":
      return HealthCheckResponse_Status.STATUS_NOT_SERVING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_Status.UNRECOGNIZED;
  }
}

export function healthCheckResponse_StatusToJSON(object: HealthCheckResponse_Status): string {
  switch (object) {
    case HealthCheckResponse_Status.STATUS_UNKNOWN:
      return "STATUS_UNKNOWN";
    case HealthCheckResponse_Status.STATUS_SERVING:
      return "STATUS_SERVING";
    case HealthCheckResponse_Status.STATUS_TRANSITIONING:
      return "STATUS_TRANSITIONING";
    case HealthCheckResponse_Status.STATUS_NOT_SERVING:
      return "STATUS_NOT_SERVING";
    case HealthCheckResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ProcessorMetrics provides runtime information about a processor */
export interface ProcessorMetrics {
  /** Number of algorithms currently being executed */
  activeTasks?:
    | number
    | undefined;
  /** Memory usage in bytes */
  memoryBytes?:
    | string
    | undefined;
  /** CPU usage percentage (0-100) */
  cpuPercent?:
    | number
    | undefined;
  /** Time since processor started in seconds */
  uptimeSeconds?: string | undefined;
}

/**
 * InternalState provides a complete snapshot of Orca's registry.
 * This is used by clients to "clone" the remote state into local code stubs.
 */
export interface InternalState {
  /** Global list of all registered processors and their metadata */
  processors?: ProcessorRegistration[] | undefined;
}

function createBaseExposeSettings(): ExposeSettings {
  return { excludeProject: "" };
}

export const ExposeSettings: MessageFns<ExposeSettings> = {
  encode(message: ExposeSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.excludeProject !== undefined && message.excludeProject !== "") {
      writer.uint32(10).string(message.excludeProject);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExposeSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExposeSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.excludeProject = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExposeSettings {
    return { excludeProject: isSet(object.excludeProject) ? globalThis.String(object.excludeProject) : "" };
  },

  toJSON(message: ExposeSettings): unknown {
    const obj: any = {};
    if (message.excludeProject !== undefined && message.excludeProject !== "") {
      obj.excludeProject = message.excludeProject;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExposeSettings>, I>>(base?: I): ExposeSettings {
    return ExposeSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExposeSettings>, I>>(object: I): ExposeSettings {
    const message = createBaseExposeSettings();
    message.excludeProject = object.excludeProject ?? "";
    return message;
  },
};

function createBaseWindow(): Window {
  return {
    timeFrom: undefined,
    timeTo: undefined,
    windowTypeName: "",
    windowTypeVersion: "",
    origin: "",
    metadata: undefined,
  };
}

export const Window: MessageFns<Window> = {
  encode(message: Window, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.timeFrom), writer.uint32(10).fork()).join();
    }
    if (message.timeTo !== undefined) {
      Timestamp.encode(toTimestamp(message.timeTo), writer.uint32(18).fork()).join();
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      writer.uint32(26).string(message.windowTypeName);
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      writer.uint32(34).string(message.windowTypeVersion);
    }
    if (message.origin !== undefined && message.origin !== "") {
      writer.uint32(42).string(message.origin);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Window {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowTypeVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.origin = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Window {
    return {
      timeFrom: isSet(object.timeFrom) ? fromJsonTimestamp(object.timeFrom) : undefined,
      timeTo: isSet(object.timeTo) ? fromJsonTimestamp(object.timeTo) : undefined,
      windowTypeName: isSet(object.windowTypeName) ? globalThis.String(object.windowTypeName) : "",
      windowTypeVersion: isSet(object.windowTypeVersion) ? globalThis.String(object.windowTypeVersion) : "",
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: Window): unknown {
    const obj: any = {};
    if (message.timeFrom !== undefined) {
      obj.timeFrom = message.timeFrom.toISOString();
    }
    if (message.timeTo !== undefined) {
      obj.timeTo = message.timeTo.toISOString();
    }
    if (message.windowTypeName !== undefined && message.windowTypeName !== "") {
      obj.windowTypeName = message.windowTypeName;
    }
    if (message.windowTypeVersion !== undefined && message.windowTypeVersion !== "") {
      obj.windowTypeVersion = message.windowTypeVersion;
    }
    if (message.origin !== undefined && message.origin !== "") {
      obj.origin = message.origin;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Window>, I>>(base?: I): Window {
    return Window.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Window>, I>>(object: I): Window {
    const message = createBaseWindow();
    message.timeFrom = object.timeFrom ?? undefined;
    message.timeTo = object.timeTo ?? undefined;
    message.windowTypeName = object.windowTypeName ?? "";
    message.windowTypeVersion = object.windowTypeVersion ?? "";
    message.origin = object.origin ?? "";
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseMetadataField(): MetadataField {
  return { name: "", description: "" };
}

export const MetadataField: MessageFns<MetadataField> = {
  encode(message: MetadataField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataField {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: MetadataField): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataField>, I>>(base?: I): MetadataField {
    return MetadataField.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataField>, I>>(object: I): MetadataField {
    const message = createBaseMetadataField();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseWindowType(): WindowType {
  return { name: "", version: "", description: "", metadataFields: [] };
}

export const WindowType: MessageFns<WindowType> = {
  encode(message: WindowType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.metadataFields !== undefined && message.metadataFields.length !== 0) {
      for (const v of message.metadataFields) {
        MetadataField.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = MetadataField.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.metadataFields!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      metadataFields: globalThis.Array.isArray(object?.metadataFields)
        ? object.metadataFields.map((e: any) => MetadataField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WindowType): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadataFields?.length) {
      obj.metadataFields = message.metadataFields.map((e) => MetadataField.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowType>, I>>(base?: I): WindowType {
    return WindowType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowType>, I>>(object: I): WindowType {
    const message = createBaseWindowType();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? "";
    message.metadataFields = object.metadataFields?.map((e) => MetadataField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWindowEmitStatus(): WindowEmitStatus {
  return { status: 0 };
}

export const WindowEmitStatus: MessageFns<WindowEmitStatus> = {
  encode(message: WindowEmitStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowEmitStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowEmitStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowEmitStatus {
    return { status: isSet(object.status) ? windowEmitStatus_StatusEnumFromJSON(object.status) : 0 };
  },

  toJSON(message: WindowEmitStatus): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = windowEmitStatus_StatusEnumToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(base?: I): WindowEmitStatus {
    return WindowEmitStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WindowEmitStatus>, I>>(object: I): WindowEmitStatus {
    const message = createBaseWindowEmitStatus();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseAlgorithmDependency(): AlgorithmDependency {
  return { name: "", version: "", processorName: "", processorRuntime: "", lookback: undefined };
}

export const AlgorithmDependency: MessageFns<AlgorithmDependency> = {
  encode(message: AlgorithmDependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      writer.uint32(26).string(message.processorName);
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      writer.uint32(34).string(message.processorRuntime);
    }
    switch (message.lookback?.$case) {
      case "lookbackNum":
        writer.uint32(40).uint32(message.lookback.value);
        break;
      case "lookbackTimeDelta":
        writer.uint32(48).uint64(message.lookback.value);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmDependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processorName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.processorRuntime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lookback = { $case: "lookbackNum", value: reader.uint32() };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lookback = { $case: "lookbackTimeDelta", value: reader.uint64().toString() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmDependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      processorName: isSet(object.processorName) ? globalThis.String(object.processorName) : "",
      processorRuntime: isSet(object.processorRuntime) ? globalThis.String(object.processorRuntime) : "",
      lookback: isSet(object.lookbackNum)
        ? { $case: "lookbackNum", value: globalThis.Number(object.lookbackNum) }
        : isSet(object.lookbackTimeDelta)
        ? { $case: "lookbackTimeDelta", value: globalThis.String(object.lookbackTimeDelta) }
        : undefined,
    };
  },

  toJSON(message: AlgorithmDependency): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.processorName !== undefined && message.processorName !== "") {
      obj.processorName = message.processorName;
    }
    if (message.processorRuntime !== undefined && message.processorRuntime !== "") {
      obj.processorRuntime = message.processorRuntime;
    }
    if (message.lookback?.$case === "lookbackNum") {
      obj.lookbackNum = Math.round(message.lookback.value);
    } else if (message.lookback?.$case === "lookbackTimeDelta") {
      obj.lookbackTimeDelta = message.lookback.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(base?: I): AlgorithmDependency {
    return AlgorithmDependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmDependency>, I>>(object: I): AlgorithmDependency {
    const message = createBaseAlgorithmDependency();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.processorName = object.processorName ?? "";
    message.processorRuntime = object.processorRuntime ?? "";
    switch (object.lookback?.$case) {
      case "lookbackNum": {
        if (object.lookback?.value !== undefined && object.lookback?.value !== null) {
          message.lookback = { $case: "lookbackNum", value: object.lookback.value };
        }
        break;
      }
      case "lookbackTimeDelta": {
        if (object.lookback?.value !== undefined && object.lookback?.value !== null) {
          message.lookback = { $case: "lookbackTimeDelta", value: object.lookback.value };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAlgorithm(): Algorithm {
  return { name: "", version: "", windowType: undefined, dependencies: [], resultType: 0, description: "" };
}

export const Algorithm: MessageFns<Algorithm> = {
  encode(message: Algorithm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== undefined && message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.windowType !== undefined) {
      WindowType.encode(message.windowType, writer.uint32(26).fork()).join();
    }
    if (message.dependencies !== undefined && message.dependencies.length !== 0) {
      for (const v of message.dependencies) {
        AlgorithmDependency.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.resultType !== undefined && message.resultType !== 0) {
      writer.uint32(40).int32(message.resultType);
    }
    if (message.description !== undefined && message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Algorithm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.windowType = WindowType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = AlgorithmDependency.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencies!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.resultType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Algorithm {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      windowType: isSet(object.windowType) ? WindowType.fromJSON(object.windowType) : undefined,
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => AlgorithmDependency.fromJSON(e))
        : [],
      resultType: isSet(object.resultType) ? resultTypeFromJSON(object.resultType) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Algorithm): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined && message.version !== "") {
      obj.version = message.version;
    }
    if (message.windowType !== undefined) {
      obj.windowType = WindowType.toJSON(message.windowType);
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => AlgorithmDependency.toJSON(e));
    }
    if (message.resultType !== undefined && message.resultType !== 0) {
      obj.resultType = resultTypeToJSON(message.resultType);
    }
    if (message.description !== undefined && message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Algorithm>, I>>(base?: I): Algorithm {
    return Algorithm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Algorithm>, I>>(object: I): Algorithm {
    const message = createBaseAlgorithm();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.windowType = (object.windowType !== undefined && object.windowType !== null)
      ? WindowType.fromPartial(object.windowType)
      : undefined;
    message.dependencies = object.dependencies?.map((e) => AlgorithmDependency.fromPartial(e)) || [];
    message.resultType = object.resultType ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseFloatArray(): FloatArray {
  return { values: [] };
}

export const FloatArray: MessageFns<FloatArray> = {
  encode(message: FloatArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.values !== undefined && message.values.length !== 0) {
      writer.uint32(10).fork();
      for (const v of message.values) {
        writer.float(v);
      }
      writer.join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 13) {
            message.values!.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values!.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: FloatArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FloatArray>, I>>(base?: I): FloatArray {
    return FloatArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FloatArray>, I>>(object: I): FloatArray {
    const message = createBaseFloatArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseResult(): Result {
  return { status: 0, resultData: undefined, timestamp: "0" };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    switch (message.resultData?.$case) {
      case "singleValue":
        writer.uint32(21).float(message.resultData.value);
        break;
      case "floatValues":
        FloatArray.encode(message.resultData.value, writer.uint32(26).fork()).join();
        break;
      case "structValue":
        Struct.encode(Struct.wrap(message.resultData.value), writer.uint32(34).fork()).join();
        break;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(40).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.resultData = { $case: "singleValue", value: reader.float() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resultData = { $case: "floatValues", value: FloatArray.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resultData = { $case: "structValue", value: Struct.unwrap(Struct.decode(reader, reader.uint32())) };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      status: isSet(object.status) ? resultStatusFromJSON(object.status) : 0,
      resultData: isSet(object.singleValue)
        ? { $case: "singleValue", value: globalThis.Number(object.singleValue) }
        : isSet(object.floatValues)
        ? { $case: "floatValues", value: FloatArray.fromJSON(object.floatValues) }
        : isSet(object.structValue)
        ? { $case: "structValue", value: object.structValue }
        : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = resultStatusToJSON(message.status);
    }
    if (message.resultData?.$case === "singleValue") {
      obj.singleValue = message.resultData.value;
    } else if (message.resultData?.$case === "floatValues") {
      obj.floatValues = FloatArray.toJSON(message.resultData.value);
    } else if (message.resultData?.$case === "structValue") {
      obj.structValue = message.resultData.value;
    }
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.status = object.status ?? 0;
    switch (object.resultData?.$case) {
      case "singleValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "singleValue", value: object.resultData.value };
        }
        break;
      }
      case "floatValues": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "floatValues", value: FloatArray.fromPartial(object.resultData.value) };
        }
        break;
      }
      case "structValue": {
        if (object.resultData?.value !== undefined && object.resultData?.value !== null) {
          message.resultData = { $case: "structValue", value: object.resultData.value };
        }
        break;
      }
    }
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseProcessorRegistration(): ProcessorRegistration {
  return { name: "", runtime: "", connectionStr: "", supportedAlgorithms: [], projectName: "" };
}

export const ProcessorRegistration: MessageFns<ProcessorRegistration> = {
  encode(message: ProcessorRegistration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      writer.uint32(18).string(message.runtime);
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      writer.uint32(26).string(message.connectionStr);
    }
    if (message.supportedAlgorithms !== undefined && message.supportedAlgorithms.length !== 0) {
      for (const v of message.supportedAlgorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    if (message.projectName !== undefined && message.projectName !== "") {
      writer.uint32(42).string(message.projectName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorRegistration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runtime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectionStr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.supportedAlgorithms!.push(el);
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.projectName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorRegistration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      connectionStr: isSet(object.connectionStr) ? globalThis.String(object.connectionStr) : "",
      supportedAlgorithms: globalThis.Array.isArray(object?.supportedAlgorithms)
        ? object.supportedAlgorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
      projectName: isSet(object.projectName) ? globalThis.String(object.projectName) : "",
    };
  },

  toJSON(message: ProcessorRegistration): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.runtime !== undefined && message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.connectionStr !== undefined && message.connectionStr !== "") {
      obj.connectionStr = message.connectionStr;
    }
    if (message.supportedAlgorithms?.length) {
      obj.supportedAlgorithms = message.supportedAlgorithms.map((e) => Algorithm.toJSON(e));
    }
    if (message.projectName !== undefined && message.projectName !== "") {
      obj.projectName = message.projectName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(base?: I): ProcessorRegistration {
    return ProcessorRegistration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorRegistration>, I>>(object: I): ProcessorRegistration {
    const message = createBaseProcessorRegistration();
    message.name = object.name ?? "";
    message.runtime = object.runtime ?? "";
    message.connectionStr = object.connectionStr ?? "";
    message.supportedAlgorithms = object.supportedAlgorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    message.projectName = object.projectName ?? "";
    return message;
  },
};

function createBaseProcessingTask(): ProcessingTask {
  return { taskId: "", algorithm: undefined, window: undefined, dependencyResults: [] };
}

export const ProcessingTask: MessageFns<ProcessingTask> = {
  encode(message: ProcessingTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== undefined && message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(18).fork()).join();
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(26).fork()).join();
    }
    if (message.dependencyResults !== undefined && message.dependencyResults.length !== 0) {
      for (const v of message.dependencyResults) {
        Result.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessingTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessingTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Result.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.dependencyResults!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessingTask {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      dependencyResults: globalThis.Array.isArray(object?.dependencyResults)
        ? object.dependencyResults.map((e: any) => Result.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProcessingTask): unknown {
    const obj: any = {};
    if (message.taskId !== undefined && message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.dependencyResults?.length) {
      obj.dependencyResults = message.dependencyResults.map((e) => Result.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessingTask>, I>>(base?: I): ProcessingTask {
    return ProcessingTask.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessingTask>, I>>(object: I): ProcessingTask {
    const message = createBaseProcessingTask();
    message.taskId = object.taskId ?? "";
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.dependencyResults = object.dependencyResults?.map((e) => Result.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionRequest(): ExecutionRequest {
  return { execId: "", window: undefined, algorithmResults: [], algorithms: [] };
}

export const ExecutionRequest: MessageFns<ExecutionRequest> = {
  encode(message: ExecutionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.window !== undefined) {
      Window.encode(message.window, writer.uint32(18).fork()).join();
    }
    if (message.algorithmResults !== undefined && message.algorithmResults.length !== 0) {
      for (const v of message.algorithmResults) {
        AlgorithmResult.encode(v!, writer.uint32(26).fork()).join();
      }
    }
    if (message.algorithms !== undefined && message.algorithms.length !== 0) {
      for (const v of message.algorithms) {
        Algorithm.encode(v!, writer.uint32(34).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.window = Window.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const el = AlgorithmResult.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithmResults!.push(el);
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const el = Algorithm.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.algorithms!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionRequest {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      window: isSet(object.window) ? Window.fromJSON(object.window) : undefined,
      algorithmResults: globalThis.Array.isArray(object?.algorithmResults)
        ? object.algorithmResults.map((e: any) => AlgorithmResult.fromJSON(e))
        : [],
      algorithms: globalThis.Array.isArray(object?.algorithms)
        ? object.algorithms.map((e: any) => Algorithm.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecutionRequest): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.window !== undefined) {
      obj.window = Window.toJSON(message.window);
    }
    if (message.algorithmResults?.length) {
      obj.algorithmResults = message.algorithmResults.map((e) => AlgorithmResult.toJSON(e));
    }
    if (message.algorithms?.length) {
      obj.algorithms = message.algorithms.map((e) => Algorithm.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionRequest>, I>>(base?: I): ExecutionRequest {
    return ExecutionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionRequest>, I>>(object: I): ExecutionRequest {
    const message = createBaseExecutionRequest();
    message.execId = object.execId ?? "";
    message.window = (object.window !== undefined && object.window !== null)
      ? Window.fromPartial(object.window)
      : undefined;
    message.algorithmResults = object.algorithmResults?.map((e) => AlgorithmResult.fromPartial(e)) || [];
    message.algorithms = object.algorithms?.map((e) => Algorithm.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExecutionResult(): ExecutionResult {
  return { execId: "", algorithmResult: undefined };
}

export const ExecutionResult: MessageFns<ExecutionResult> = {
  encode(message: ExecutionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.execId !== undefined && message.execId !== "") {
      writer.uint32(10).string(message.execId);
    }
    if (message.algorithmResult !== undefined) {
      AlgorithmResult.encode(message.algorithmResult, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.execId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithmResult = AlgorithmResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionResult {
    return {
      execId: isSet(object.execId) ? globalThis.String(object.execId) : "",
      algorithmResult: isSet(object.algorithmResult) ? AlgorithmResult.fromJSON(object.algorithmResult) : undefined,
    };
  },

  toJSON(message: ExecutionResult): unknown {
    const obj: any = {};
    if (message.execId !== undefined && message.execId !== "") {
      obj.execId = message.execId;
    }
    if (message.algorithmResult !== undefined) {
      obj.algorithmResult = AlgorithmResult.toJSON(message.algorithmResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecutionResult>, I>>(base?: I): ExecutionResult {
    return ExecutionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecutionResult>, I>>(object: I): ExecutionResult {
    const message = createBaseExecutionResult();
    message.execId = object.execId ?? "";
    message.algorithmResult = (object.algorithmResult !== undefined && object.algorithmResult !== null)
      ? AlgorithmResult.fromPartial(object.algorithmResult)
      : undefined;
    return message;
  },
};

function createBaseAlgorithmResult(): AlgorithmResult {
  return { algorithm: undefined, result: undefined };
}

export const AlgorithmResult: MessageFns<AlgorithmResult> = {
  encode(message: AlgorithmResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== undefined) {
      Algorithm.encode(message.algorithm, writer.uint32(10).fork()).join();
    }
    if (message.result !== undefined) {
      Result.encode(message.result, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithm = Algorithm.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = Result.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmResult {
    return {
      algorithm: isSet(object.algorithm) ? Algorithm.fromJSON(object.algorithm) : undefined,
      result: isSet(object.result) ? Result.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: AlgorithmResult): unknown {
    const obj: any = {};
    if (message.algorithm !== undefined) {
      obj.algorithm = Algorithm.toJSON(message.algorithm);
    }
    if (message.result !== undefined) {
      obj.result = Result.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AlgorithmResult>, I>>(base?: I): AlgorithmResult {
    return AlgorithmResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AlgorithmResult>, I>>(object: I): AlgorithmResult {
    const message = createBaseAlgorithmResult();
    message.algorithm = (object.algorithm !== undefined && object.algorithm !== null)
      ? Algorithm.fromPartial(object.algorithm)
      : undefined;
    message.result = (object.result !== undefined && object.result !== null)
      ? Result.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseStatus(): Status {
  return { received: false, message: "" };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.received !== undefined && message.received !== false) {
      writer.uint32(8).bool(message.received);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.received = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      received: isSet(object.received) ? globalThis.Boolean(object.received) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.received !== undefined && message.received !== false) {
      obj.received = message.received;
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.received = object.received ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { timestamp: "0" };
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(message: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined && message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(object: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0, message: "", metrics: undefined };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined && message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.metrics !== undefined) {
      ProcessorMetrics.encode(message.metrics, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metrics = ProcessorMetrics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      status: isSet(object.status) ? healthCheckResponse_StatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      metrics: isSet(object.metrics) ? ProcessorMetrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined && message.status !== 0) {
      obj.status = healthCheckResponse_StatusToJSON(message.status);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    if (message.metrics !== undefined) {
      obj.metrics = ProcessorMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? ProcessorMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseProcessorMetrics(): ProcessorMetrics {
  return { activeTasks: 0, memoryBytes: "0", cpuPercent: 0, uptimeSeconds: "0" };
}

export const ProcessorMetrics: MessageFns<ProcessorMetrics> = {
  encode(message: ProcessorMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      writer.uint32(8).int32(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      writer.uint32(16).int64(message.memoryBytes);
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      writer.uint32(29).float(message.cpuPercent);
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      writer.uint32(32).int64(message.uptimeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessorMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeTasks = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryBytes = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.cpuPercent = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uptimeSeconds = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessorMetrics {
    return {
      activeTasks: isSet(object.activeTasks) ? globalThis.Number(object.activeTasks) : 0,
      memoryBytes: isSet(object.memoryBytes) ? globalThis.String(object.memoryBytes) : "0",
      cpuPercent: isSet(object.cpuPercent) ? globalThis.Number(object.cpuPercent) : 0,
      uptimeSeconds: isSet(object.uptimeSeconds) ? globalThis.String(object.uptimeSeconds) : "0",
    };
  },

  toJSON(message: ProcessorMetrics): unknown {
    const obj: any = {};
    if (message.activeTasks !== undefined && message.activeTasks !== 0) {
      obj.activeTasks = Math.round(message.activeTasks);
    }
    if (message.memoryBytes !== undefined && message.memoryBytes !== "0") {
      obj.memoryBytes = message.memoryBytes;
    }
    if (message.cpuPercent !== undefined && message.cpuPercent !== 0) {
      obj.cpuPercent = message.cpuPercent;
    }
    if (message.uptimeSeconds !== undefined && message.uptimeSeconds !== "0") {
      obj.uptimeSeconds = message.uptimeSeconds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(base?: I): ProcessorMetrics {
    return ProcessorMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorMetrics>, I>>(object: I): ProcessorMetrics {
    const message = createBaseProcessorMetrics();
    message.activeTasks = object.activeTasks ?? 0;
    message.memoryBytes = object.memoryBytes ?? "0";
    message.cpuPercent = object.cpuPercent ?? 0;
    message.uptimeSeconds = object.uptimeSeconds ?? "0";
    return message;
  },
};

function createBaseInternalState(): InternalState {
  return { processors: [] };
}

export const InternalState: MessageFns<InternalState> = {
  encode(message: InternalState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processors !== undefined && message.processors.length !== 0) {
      for (const v of message.processors) {
        ProcessorRegistration.encode(v!, writer.uint32(10).fork()).join();
      }
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InternalState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const el = ProcessorRegistration.decode(reader, reader.uint32());
          if (el !== undefined) {
            message.processors!.push(el);
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalState {
    return {
      processors: globalThis.Array.isArray(object?.processors)
        ? object.processors.map((e: any) => ProcessorRegistration.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InternalState): unknown {
    const obj: any = {};
    if (message.processors?.length) {
      obj.processors = message.processors.map((e) => ProcessorRegistration.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InternalState>, I>>(base?: I): InternalState {
    return InternalState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InternalState>, I>>(object: I): InternalState {
    const message = createBaseInternalState();
    message.processors = object.processors?.map((e) => ProcessorRegistration.fromPartial(e)) || [];
    return message;
  },
};

/**
 * OrcaCore is the central orchestration service that:
 * - Manages the lifecycle of processing windows
 * - Coordinates algorithm execution across distributed processors
 * - Tracks DAG dependencies and execution state
 * - Routes results between dependent algorithms
 */
export type OrcaCoreService = typeof OrcaCoreService;
export const OrcaCoreService = {
  /** Register a processor node and its supported algorithms */
  registerProcessor: {
    path: "/OrcaCore/RegisterProcessor",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ProcessorRegistration): Buffer =>
      Buffer.from(ProcessorRegistration.encode(value).finish()),
    requestDeserialize: (value: Buffer): ProcessorRegistration => ProcessorRegistration.decode(value),
    responseSerialize: (value: Status): Buffer => Buffer.from(Status.encode(value).finish()),
    responseDeserialize: (value: Buffer): Status => Status.decode(value),
  },
  /** Submit a window for processing */
  emitWindow: {
    path: "/OrcaCore/EmitWindow",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Window): Buffer => Buffer.from(Window.encode(value).finish()),
    requestDeserialize: (value: Buffer): Window => Window.decode(value),
    responseSerialize: (value: WindowEmitStatus): Buffer => Buffer.from(WindowEmitStatus.encode(value).finish()),
    responseDeserialize: (value: Buffer): WindowEmitStatus => WindowEmitStatus.decode(value),
  },
  /** Expose the internal Orca state */
  expose: {
    path: "/OrcaCore/Expose",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExposeSettings): Buffer => Buffer.from(ExposeSettings.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExposeSettings => ExposeSettings.decode(value),
    responseSerialize: (value: InternalState): Buffer => Buffer.from(InternalState.encode(value).finish()),
    responseDeserialize: (value: Buffer): InternalState => InternalState.decode(value),
  },
} as const;

export interface OrcaCoreServer extends UntypedServiceImplementation {
  /** Register a processor node and its supported algorithms */
  registerProcessor: handleUnaryCall<ProcessorRegistration, Status>;
  /** Submit a window for processing */
  emitWindow: handleUnaryCall<Window, WindowEmitStatus>;
  /** Expose the internal Orca state */
  expose: handleUnaryCall<ExposeSettings, InternalState>;
}

export interface OrcaCoreClient extends Client {
  /** Register a processor node and its supported algorithms */
  registerProcessor(
    request: ProcessorRegistration,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  registerProcessor(
    request: ProcessorRegistration,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Status) => void,
  ): ClientUnaryCall;
  /** Submit a window for processing */
  emitWindow(
    request: Window,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  emitWindow(
    request: Window,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WindowEmitStatus) => void,
  ): ClientUnaryCall;
  /** Expose the internal Orca state */
  expose(
    request: ExposeSettings,
    callback: (error: ServiceError | null, response: InternalState) => void,
  ): ClientUnaryCall;
  expose(
    request: ExposeSettings,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: InternalState) => void,
  ): ClientUnaryCall;
  expose(
    request: ExposeSettings,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: InternalState) => void,
  ): ClientUnaryCall;
}

export const OrcaCoreClient = makeGenericClientConstructor(OrcaCoreService, "OrcaCore") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaCoreClient;
  service: typeof OrcaCoreService;
  serviceName: string;
};

/**
 * OrcaProcessor defines the interface that each processing node must implement.
 * Processors are language-agnostic services that:
 * - Execute individual algorithms
 * - Handle their own internal state
 * - Report results back to the orchestrator
 * Orca will schedule processors asynchronously as per the DAG
 */
export type OrcaProcessorService = typeof OrcaProcessorService;
export const OrcaProcessorService = {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: {
    path: "/OrcaProcessor/ExecuteDagPart",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ExecutionRequest): Buffer => Buffer.from(ExecutionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecutionRequest => ExecutionRequest.decode(value),
    responseSerialize: (value: ExecutionResult): Buffer => Buffer.from(ExecutionResult.encode(value).finish()),
    responseDeserialize: (value: Buffer): ExecutionResult => ExecutionResult.decode(value),
  },
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: {
    path: "/OrcaProcessor/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest): Buffer => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthCheckRequest => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse): Buffer => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthCheckResponse => HealthCheckResponse.decode(value),
  },
} as const;

export interface OrcaProcessorServer extends UntypedServiceImplementation {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart: handleServerStreamingCall<ExecutionRequest, ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface OrcaProcessorClient extends Client {
  /**
   * Execute part of a DAG with streaming results
   * Server streams back execution results as they become available
   */
  executeDagPart(request: ExecutionRequest, options?: Partial<CallOptions>): ClientReadableStream<ExecutionResult>;
  executeDagPart(
    request: ExecutionRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<ExecutionResult>;
  /** Check health/status of processor. i.e. a heartbeat */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const OrcaProcessorClient = makeGenericClientConstructor(OrcaProcessorService, "OrcaProcessor") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): OrcaProcessorClient;
  service: typeof OrcaProcessorService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
